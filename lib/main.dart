// NisanApp - ENHANCED VERSION
// Includes a Tools Hub with a Calculator and an advanced, custom Category Management system.
// Also includes previous enhancements: Task Archiving, Focus-to-Task Linking, a new Stats Chart, and UI/UX polish.

// All imports are grouped and sorted for clarity.
import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:math';

// Firebase Imports
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart' as fb_auth; // Aliased to avoid name conflicts
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'firebase_options.dart'; // IMPORTANT: This file is generated by `flutterfire configure`
import 'package:firebase_app_check/firebase_app_check.dart';

// Flutter and Package Imports
import 'package:file_picker/file_picker.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart' as fln;
import 'package:flutter_slidable/flutter_slidable.dart';
import 'package:intl/intl.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:path_provider/path_provider.dart';
import 'package:percent_indicator/percent_indicator.dart';
import 'package:pie_chart/pie_chart.dart';
import 'package:provider/provider.dart';
import 'package:receive_intent/receive_intent.dart' as receive_intent;
import 'package:shared_preferences/shared_preferences.dart';
import 'package:share_plus/share_plus.dart';
import 'package:table_calendar/table_calendar.dart';
import 'package:timezone/data/latest.dart' as tz;
import 'package:timezone/timezone.dart' as tz;
import 'package:url_launcher/url_launcher.dart';
import 'package:uuid/uuid.dart';
import 'package:math_expressions/math_expressions.dart' hide Stack;


// --- NEW IMPORTS FOR FILE VIEWING ---
import 'package:open_app_file/open_app_file.dart';
import 'package:flutter_cached_pdfview/flutter_cached_pdfview.dart';
import 'package:extended_image/extended_image.dart';
import 'package:path/path.dart' as p_path;

// Add these imports with your other Firebase and Flutter imports
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:flutter/foundation.dart' show PlatformDispatcher, kIsWeb;
import 'package:flutter/foundation.dart' show kIsWeb;


// --- /lib/src/utils/logger.dart ---
class AppLogger {
  static final AppLogger _instance = AppLogger._internal();
  factory AppLogger() => _instance;
  AppLogger._internal();

  void log(String message) {
    // This will still print to the console during development
    debugPrint('[NisanApp] $message');

    // This will send the log message to Crashlytics to be attached to any crash reports
    FirebaseCrashlytics.instance.log(message);
  }
}

// --- /lib/src/constants/app_constants.dart ---
class Constants {
  // SharedPreferences Keys
  static const String themeModeKey = 'appThemeMode';
  static const String taskDraftKey = 'taskDraft';
  static const String recentSearchesKey = 'recentSearches';
  static const String priorityUsageKey = 'priorityUsage';
  static const String lastSeenVersionKey = 'lastSeenVersion';
  static const String lastPlanningDateKey = 'lastPlanningDate';
  static const String currentStreakKey = 'currentStreak';
  static const String lastCompletionDateKey = 'lastCompletionDate';
  static const String hasSeenOnboardingKey = 'hasSeenOnboarding';
  static const String hasAgreedToTermsKey = 'hasAgreedToTerms';

  // Route Names
  static const String splashRoute = '/';
  static const String authWrapperRoute = '/auth';
  static const String onboardingRoute = '/onboarding';
  static const String agreementRoute = '/agreement';
  static const String welcomeRoute = '/welcome';
  static const String homeRoute = '/home';
  static const String addTaskRoute = '/addTask';
  static const String addSubtaskRoute = '/addSubtask';
  static const String signInRoute = '/signin';
  static const String signUpRoute = '/signup';
  static const String taskDetailRoute = '/taskDetail';
  static const String settingsRoute = '/settings';
  static const String aboutRoute = '/about';
  static const String statsRoute = '/stats';
  static const String noteDetailRoute = '/noteDetail';
  static const String termsRoute = '/terms';
  static const String privacyPolicyRoute = '/privacy';
  static const String changePasswordRoute = '/changePassword';
  static const String accountRoute = '/account';
  static const String planningRoute = '/planning';
  static const String focusRoute = '/focus';
  static const String changeUsernameRoute = '/changeUsername';
  static const String archivedTasksRoute = '/archivedTasks';
  // NEW: Routes for Calculator and Category Management
  static const String toolsRoute = '/tools';
  static const String manageCategoriesRoute = '/manageCategories';
  static const String categoryContentsRoute = '/categoryContents';

  // Firestore Collections
  static const String usersCollection = 'users';
  static const String tasksCollection = 'tasks';
  static const String notesCollection = 'notes';
}

// --- /lib/src/data/notification_service.dart ---
class NotificationService {
  final fln.FlutterLocalNotificationsPlugin _notificationsPlugin =
  fln.FlutterLocalNotificationsPlugin();
  final AppLogger _logger = AppLogger();

  static const int _persistentDashboardId = 0;
  static const int _ongoingFocusId = 1;

  static const fln.AndroidNotificationDetails _highPriorityAndroidDetails =
  fln.AndroidNotificationDetails(
    'nisan_app_high_importance_channel',
    'High-Importance Alerts',
    channelDescription: 'Heads-up notifications for critical alerts like task reminders and timer completions.',
    importance: fln.Importance.max,
    priority: fln.Priority.max,
    ticker: 'ticker',
    playSound: true,
    enableVibration: true,
  );
  static const fln.DarwinNotificationDetails _highPriorityDarwinDetails =
  fln.DarwinNotificationDetails(presentSound: true);
  static const fln.NotificationDetails _highPriorityDetails = fln.NotificationDetails(
      android: _highPriorityAndroidDetails, iOS: _highPriorityDarwinDetails);


  Future<void> init() async {
    const fln.AndroidInitializationSettings androidSettings =
    fln.AndroidInitializationSettings('@mipmap/ic_launcher');
    final fln.DarwinInitializationSettings darwinSettings =
    fln.DarwinInitializationSettings(
        requestAlertPermission: true,
        requestBadgePermission: true,
        requestSoundPermission: true);
    final fln.InitializationSettings settings = fln.InitializationSettings(
        android: androidSettings, iOS: darwinSettings);

    await _notificationsPlugin.initialize(settings,
        onDidReceiveNotificationResponse: (fln.NotificationResponse response) {
          _logger.log("Notification tapped with payload: ${response.payload}");
        });
    _logger.log("NotificationService Initialized.");
  }

  Future<void> requestPermissions() async {
    // Add this check to skip the whole function on web
    if (kIsWeb) {
      _logger.log("Notification permissions not applicable for web.");
      return;
    }
    if (Platform.isIOS) {
      await _notificationsPlugin
          .resolvePlatformSpecificImplementation<
          fln.IOSFlutterLocalNotificationsPlugin>()
          ?.requestPermissions(alert: true, badge: true, sound: true);
      _logger.log("iOS Notification Permissions requested.");
    } else if (Platform.isAndroid) {
      final fln.AndroidFlutterLocalNotificationsPlugin? androidImplementation =
      _notificationsPlugin.resolvePlatformSpecificImplementation<
          fln.AndroidFlutterLocalNotificationsPlugin>();
      await androidImplementation?.requestNotificationsPermission();
      await androidImplementation?.requestExactAlarmsPermission();
      _logger.log("Android Notification & Exact Alarm Permissions requested.");
    }
  }

  Future<void> showPersistentDashboardNotification() async {
    const androidDetails = fln.AndroidNotificationDetails(
      'nisan_app_dashboard_channel',
      'App Shortcut',
      channelDescription: 'A persistent notification to quickly open the app.',
      importance: fln.Importance.defaultImportance,
      priority: fln.Priority.defaultPriority,
      ongoing: true,
      autoCancel: false,
    );
    const notificationDetails =
    fln.NotificationDetails(android: androidDetails);
    await _notificationsPlugin.show(
      _persistentDashboardId,
      "NisanApp is running",
      "Tap to open your workspace.",
      notificationDetails,
    );
    _logger.log("Showing persistent dashboard notification.");
  }

  Future<void> showOngoingFocusNotification(String title, String body) async {
    const androidDetails = fln.AndroidNotificationDetails(
      'nisan_app_focus_timer',
      'Focus Session',
      channelDescription: 'Persistent notification for an active focus session.',
      importance: fln.Importance.low,
      priority: fln.Priority.low,
      ongoing: true,
      autoCancel: false,
      onlyAlertOnce: true,
    );
    const darwinDetails = fln.DarwinNotificationDetails(presentSound: false);
    final notificationDetails =
    fln.NotificationDetails(android: androidDetails, iOS: darwinDetails);
    await _notificationsPlugin.show(_ongoingFocusId, title, body, notificationDetails);
  }

  Future<void> cancelOngoingFocusNotification() async {
    await _notificationsPlugin.cancel(_ongoingFocusId);
    _logger.log("Cancelled ongoing focus notification.");
  }

  Future<void> showTimerCompletionNotification(String title, String body) async {
    await _notificationsPlugin.show(
      // Use a consistent ID for completion to avoid stacking them
      2,
      title,
      body,
      _highPriorityDetails,
    );
    _logger.log("Showing HIGH PRIORITY timer completion notification.");
  }

  Future<void> scheduleTaskReminder(
      int id, String title, String body, DateTime scheduledTime) async {
    if (scheduledTime.isBefore(DateTime.now())) {
      _logger.log(
          "Attempted to schedule a notification in the past for '$title'. Skipping.");
      return;
    }
    await _notificationsPlugin.zonedSchedule(
      id,
      title,
      body,
      tz.TZDateTime.from(scheduledTime, tz.local),
      _highPriorityDetails,
      androidScheduleMode: fln.AndroidScheduleMode.exactAllowWhileIdle,
      // The 'uiLocalNotificationDateInterpretation' parameter has been removed.
    );
    _logger.log("Scheduled HIGH PRIORITY notification for task '$title' at $scheduledTime");
  }

  Future<void> cancelNotification(int id) async {
    await _notificationsPlugin.cancel(id);
    _logger.log("Cancelled notification with ID: $id");
  }
}

// --- /lib/src/data/models/attachment_model.dart ---
enum AttachmentType { image, pdf, audio, other }
class Attachment {
  final String id;
  final String localPath;
  final String fileName;
  final AttachmentType type;

  Attachment({required this.id, required this.localPath, required this.fileName, required this.type});

  Map<String, dynamic> toMap() => {
    'id': id,
    'localPath': localPath,
    'fileName': fileName,
    'type': type.index,
  };

  factory Attachment.fromMap(Map<String, dynamic> map) {
    return Attachment(
      id: map['id'] ?? '',
      localPath: map['localPath'] ?? '',
      fileName: map['fileName'] ?? 'Unknown File',
      type: (map['type'] != null && map['type'] < AttachmentType.values.length) ? AttachmentType.values[map['type']] : AttachmentType.other,
    );
  }
}

// --- /lib/src/data/models/subtask_model.dart ---
class Subtask {
  final String id;
  String title;
  bool isCompleted;

  Subtask({required this.id, required this.title, this.isCompleted = false});

  Map<String, dynamic> toMap() => {'id': id, 'title': title, 'isCompleted': isCompleted};
  factory Subtask.fromMap(Map<String, dynamic> map) => Subtask(id: map['id'], title: map['title'], isCompleted: map['isCompleted']);
}

// --- /lib/src/data/models/recurrence_rule_model.dart ---
enum RecurrenceFrequency { daily, weekly, monthly }
class RecurrenceRule {
  final RecurrenceFrequency frequency;
  final int interval;

  RecurrenceRule({required this.frequency, this.interval = 1});

  Map<String, dynamic> toMap() => {'frequency': frequency.index, 'interval': interval};
  factory RecurrenceRule.fromMap(Map<String, dynamic> map) {
    return RecurrenceRule(
      frequency: RecurrenceFrequency.values[map['frequency'] ?? 0],
      interval: map['interval'] ?? 1,
    );
  }

  String get description {
    if (frequency == RecurrenceFrequency.daily && interval == 1) return "Repeats Daily";
    if (frequency == RecurrenceFrequency.weekly && interval == 1) return "Repeats Weekly";
    if (frequency == RecurrenceFrequency.monthly && interval == 1) return "Repeats Monthly";
    return "Repeats every $interval ${frequency.name}s";
  }
}

// --- /lib/src/features/tasks/data/task_model.dart ---
@immutable
class Task {
  final String id;
  final String userId;
  final String title;
  final String? description;
  final DateTime? dueDate;
  final Priority priority;
  final TaskStatus status;
  final DateTime creationTimestamp;
  final DateTime? completionTimestamp;
  final String? workspaceId;
  final List<String>? categories; // ADDED THIS LINE
  final int srsLevel;
  final DateTime? nextSuggestedDate;
  final List<Subtask> subtasks;
  final List<Attachment> attachments;
  final RecurrenceRule? recurrence;
  final int focusSessions;
  final int totalFocusTime; // in minutes
  final bool isDailyPriority;
  final List<String>? linkedNoteIds;
  final bool isArchived;
  final Map<String, String>? customDetails;


  const Task({
    required this.id,
    required this.userId,
    required this.title,
    this.description,
    this.dueDate,
    this.priority = Priority.medium,
    this.status = TaskStatus.notStarted,
    required this.creationTimestamp,
    this.completionTimestamp,
    this.workspaceId,
    this.categories, // ADDED THIS LINE
    this.srsLevel = 0,
    this.nextSuggestedDate,
    this.subtasks = const [],
    this.attachments = const [],
    this.recurrence,
    this.focusSessions = 0,
    this.totalFocusTime = 0,
    this.isDailyPriority = false,
    this.linkedNoteIds,
    this.isArchived = false,
    this.customDetails,
  });

  bool get isComplete => status == TaskStatus.completed;
  bool get hasDescription => description != null && description!.trim().isNotEmpty;
  double get progress {
    if (subtasks.isEmpty) return isComplete ? 1.0 : 0.0;
    if (subtasks.where((s) => s.isCompleted).isEmpty) return 0.0;
    return subtasks.where((s) => s.isCompleted).length / subtasks.length;
  }
  int get dueDayNotificationId => id.hashCode.abs();
  int get thirtyMinNotificationId => (id.hashCode.abs() + 1);


  Task copyWith({
    String? id, String? userId, String? title, String? description, DateTime? dueDate, Priority? priority, TaskStatus? status,
    DateTime? creationTimestamp, ValueGetter<DateTime?>? completionTimestamp, String? workspaceId, List<String>? categories, Map<String, String>? customDetails, int? srsLevel, DateTime? nextSuggestedDate,
    List<Subtask>? subtasks, List<Attachment>? attachments, RecurrenceRule? recurrence,
    int? focusSessions, int? totalFocusTime, bool? isDailyPriority, List<String>? linkedNoteIds, bool? isArchived,
    bool setDescriptionNull = false, bool setDueDateNull = false, bool setWorkspaceIdNull = false, bool setCategoriesNull = false, bool setCustomDetailsNull = false, bool setNextSuggestedDateNull = false, bool setRecurrenceNull = false, bool setLinkedNoteIdsNull = false,
  }) {
    return Task(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      title: title ?? this.title,
      description: setDescriptionNull ? null : description ?? this.description,
      dueDate: setDueDateNull ? null : dueDate ?? this.dueDate,
      priority: priority ?? this.priority,
      status: status ?? this.status,
      creationTimestamp: creationTimestamp ?? this.creationTimestamp,
      completionTimestamp: completionTimestamp != null ? completionTimestamp() : this.completionTimestamp,
      workspaceId: setWorkspaceIdNull ? null : workspaceId ?? this.workspaceId,
      categories: setCategoriesNull ? null : categories ?? this.categories,
      customDetails: setCustomDetailsNull ? null : customDetails ?? this.customDetails,
      srsLevel: srsLevel ?? this.srsLevel,
      nextSuggestedDate: setNextSuggestedDateNull ? null : nextSuggestedDate ?? this.nextSuggestedDate,
      subtasks: subtasks ?? this.subtasks,
      attachments: attachments ?? this.attachments,
      recurrence: setRecurrenceNull ? null : recurrence ?? this.recurrence,
      focusSessions: focusSessions ?? this.focusSessions,
      totalFocusTime: totalFocusTime ?? this.totalFocusTime,
      isDailyPriority: isDailyPriority ?? this.isDailyPriority,
      linkedNoteIds: setLinkedNoteIdsNull ? null : linkedNoteIds ?? this.linkedNoteIds,
      isArchived: isArchived ?? this.isArchived,
    );
  }

  Map<String, dynamic> toMap() => {
    'userId': userId, 'title': title, 'description': description, 'dueDate': dueDate != null ? Timestamp.fromDate(dueDate!) : null,
    'priority': priority.index, 'status': status.index, 'creationTimestamp': Timestamp.fromDate(creationTimestamp),
    'completionTimestamp': completionTimestamp != null ? Timestamp.fromDate(completionTimestamp!) : null,
    'workspaceId': workspaceId,
    'categories': categories,
    'customDetails': customDetails,
    'srsLevel': srsLevel, 'nextSuggestedDate': nextSuggestedDate != null ? Timestamp.fromDate(nextSuggestedDate!) : null,
    'subtasks': subtasks.map((s) => s.toMap()).toList(),
    'attachments': attachments.map((a) => a.toMap()).toList(),
    'recurrence': recurrence?.toMap(),
    'focusSessions': focusSessions,
    'totalFocusTime': totalFocusTime,
    'isDailyPriority': isDailyPriority,
    'linkedNoteIds': linkedNoteIds,
    'isArchived': isArchived,
  };

  factory Task.fromFirestore(DocumentSnapshot<Map<String, dynamic>> doc) {
    final map = doc.data()!;
    return Task(
      id: doc.id,
      userId: map['userId'] ?? '',
      title: map['title'] ?? 'Untitled Task',
      description: map['description'],
      dueDate: (map['dueDate'] as Timestamp?)?.toDate(),
      priority: (map['priority'] != null && map['priority'] < Priority.values.length) ? Priority.values[map['priority']] : Priority.medium,
      status: (map['status'] != null && map['status'] < TaskStatus.values.length) ? TaskStatus.values[map['status']] : TaskStatus.notStarted,
      creationTimestamp: (map['creationTimestamp'] as Timestamp? ?? Timestamp.now()).toDate(),
      completionTimestamp: (map['completionTimestamp'] as Timestamp?)?.toDate(),
      workspaceId: map['workspaceId'],
      categories: (map['categories'] as List<dynamic>?)?.cast<String>(),
      customDetails: (map['customDetails'] as Map<String, dynamic>?)?.cast<String, String>(),
      srsLevel: map['srsLevel'] ?? 0,
      nextSuggestedDate: (map['nextSuggestedDate'] as Timestamp?)?.toDate(),
      subtasks: (map['subtasks'] as List<dynamic>?)?.map((s) => Subtask.fromMap(s)).toList() ?? [],
      attachments: (map['attachments'] as List<dynamic>?)?.map((a) => Attachment.fromMap(a)).toList() ?? [],
      recurrence: map['recurrence'] != null ? RecurrenceRule.fromMap(map['recurrence']) : null,
      focusSessions: map['focusSessions'] ?? 0,
      totalFocusTime: map['totalFocusTime'] ?? 0,
      isDailyPriority: map['isDailyPriority'] ?? false,
      linkedNoteIds: (map['linkedNoteIds'] as List<dynamic>?)?.cast<String>(),
      isArchived: map['isArchived'] ?? false,
    );
  }

  bool get isReviewDue {
    if (!isComplete || nextSuggestedDate == null) return false;
    final endOfToday = DateUtils.dateOnly(DateTime.now()).add(const Duration(days: 1)).subtract(const Duration(milliseconds: 1));
    return !nextSuggestedDate!.isAfter(endOfToday);
  }
}

// --- /lib/src/features/notes/data/note_model.dart ---
/// ENHANCED: Added 'categories' field to allow notes to be categorized.
@immutable
class Note {
  final String id;
  final String userId;
  final String title;
  final String content;
  final DateTime creationTimestamp;
  final DateTime lastModifiedTimestamp;
  final bool isPinned;
  final List<Attachment> attachments;
  final List<String>? linkedTaskIds;
  final List<String>? categories; // ADDED THIS LINE

  const Note({
    required this.id,
    required this.userId,
    required this.title,
    required this.content,
    required this.creationTimestamp,
    required this.lastModifiedTimestamp,
    this.isPinned = false,
    this.attachments = const [],
    this.linkedTaskIds,
    this.categories, // ADDED THIS LINE
  });

  Note copyWith({
    String? id, String? userId, String? title, String? content,
    DateTime? creationTimestamp, DateTime? lastModifiedTimestamp,
    bool? isPinned, List<Attachment>? attachments, List<String>? linkedTaskIds,
    List<String>? categories, // ADDED THIS LINE
    bool setLinkedTaskIdsNull = false,
    bool setCategoriesNull = false // ADDED THIS LINE
  }) {
    return Note(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      title: title ?? this.title,
      content: content ?? this.content,
      creationTimestamp: creationTimestamp ?? this.creationTimestamp,
      lastModifiedTimestamp: lastModifiedTimestamp ?? this.lastModifiedTimestamp,
      isPinned: isPinned ?? this.isPinned,
      attachments: attachments ?? this.attachments,
      linkedTaskIds: setLinkedTaskIdsNull ? null : linkedTaskIds ?? this.linkedTaskIds,
      categories: setCategoriesNull ? null : categories ?? this.categories, // ADDED THIS LINE
    );
  }

  Map<String, dynamic> toMap() => {
    'userId': userId, 'title': title, 'content': content,
    'creationTimestamp': Timestamp.fromDate(creationTimestamp),
    'lastModifiedTimestamp': Timestamp.fromDate(lastModifiedTimestamp),
    'isPinned': isPinned,
    'attachments': attachments.map((a) => a.toMap()).toList(),
    'linkedTaskIds': linkedTaskIds,
    'categories': categories, // ADDED THIS LINE
  };

  factory Note.fromFirestore(DocumentSnapshot<Map<String, dynamic>> doc) {
    final map = doc.data()!;
    return Note(
      id: doc.id,
      userId: map['userId'] ?? '',
      title: map['title'] ?? 'Untitled Note',
      content: map['content'] ?? '',
      creationTimestamp: (map['creationTimestamp'] as Timestamp? ?? Timestamp.now()).toDate(),
      lastModifiedTimestamp: (map['lastModifiedTimestamp'] as Timestamp? ?? Timestamp.now()).toDate(),
      isPinned: map['isPinned'] ?? false,
      attachments: (map['attachments'] as List<dynamic>?)?.map((a) => Attachment.fromMap(a)).toList() ?? [],
      linkedTaskIds: (map['linkedTaskIds'] as List<dynamic>?)?.cast<String>(),
      categories: (map['categories'] as List<dynamic>?)?.cast<String>(), // ADDED THIS LINE
    );
  }
}

class CategoryContentsScreen extends StatefulWidget {
  final Category category;
  const CategoryContentsScreen({super.key, required this.category});

  @override
  State<CategoryContentsScreen> createState() => _CategoryContentsScreenState();
}

class _CategoryContentsScreenState extends State<CategoryContentsScreen>
    with SingleTickerProviderStateMixin {
  late final TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final taskManager = context.watch<TaskManager>();
    final noteManager = context.watch<NoteManager>();

    final categoryTasks = taskManager.originalTasks
        .where((task) => task.categories?.contains(widget.category.name) ?? false)
        .toList();
    final categoryNotes = noteManager.originalNotes
        .where((note) => note.categories?.contains(widget.category.name) ?? false)
        .toList();

    final combinedList = [...categoryTasks, ...categoryNotes];
    combinedList.sort((a, b) {
      final dateA = a is Task ? a.creationTimestamp : (a as Note).creationTimestamp;
      final dateB = b is Task ? b.creationTimestamp : (b as Note).creationTimestamp;
      return dateB.compareTo(dateA);
    });

    return Scaffold(
      appBar: AppBar(
        // **FIXED**: The title is now a Row, allowing the back button to appear automatically.
        title: Row(
          children: [
            Icon(widget.category.icon, color: widget.category.color),
            const SizedBox(width: 12),
            Text(widget.category.name),
          ],
        ),
        bottom: TabBar(
          controller: _tabController,
          tabs: [
            Tab(text: 'Tasks (${categoryTasks.length})'),
            Tab(text: 'Notes (${categoryNotes.length})'),
            Tab(text: 'All (${combinedList.length})'),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          _buildTaskList(categoryTasks),
          _buildNoteList(categoryNotes),
          _buildCombinedList(combinedList),
        ],
      ),
    );
  }

  Widget _buildTaskList(List<Task> tasks) {
    if (tasks.isEmpty) return _buildEmptyState("No tasks in this category.");
    return ListView.builder(
      padding: const EdgeInsets.fromLTRB(4, 8, 4, 88),
      itemCount: tasks.length,
      itemBuilder: (context, index) => TaskListItem(
        task: tasks[index],
        onTap: () => Navigator.pushNamed(context, Constants.taskDetailRoute,
            arguments: tasks[index].id),
        onLongPress: () {},
      ),
    );
  }

  Widget _buildNoteList(List<Note> notes) {
    if (notes.isEmpty) return _buildEmptyState("No notes in this category.");
    return ListView.builder(
      padding: const EdgeInsets.fromLTRB(4, 8, 4, 88),
      itemCount: notes.length,
      itemBuilder: (context, index) => NoteListItem(
        note: notes[index],
        onTap: () => Navigator.pushNamed(context, Constants.noteDetailRoute,
            arguments: notes[index].id),
      ),
    );
  }

  Widget _buildCombinedList(List<dynamic> items) {
    if (items.isEmpty) return _buildEmptyState("No items in this category.");
    return ListView.builder(
      padding: const EdgeInsets.fromLTRB(4, 8, 4, 88),
      itemCount: items.length,
      itemBuilder: (context, index) {
        final item = items[index];
        if (item is Task) {
          return TaskListItem(
            task: item,
            onTap: () => Navigator.pushNamed(context, Constants.taskDetailRoute,
                arguments: item.id),
            onLongPress: () {},
          );
        } else if (item is Note) {
          return NoteListItem(
            note: item,
            onTap: () => Navigator.pushNamed(context, Constants.noteDetailRoute,
                arguments: item.id),
          );
        }
        return const SizedBox.shrink();
      },
    );
  }

  Widget _buildEmptyState(String message) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.inbox_outlined, size: 60, color: Colors.grey.shade400),
          const SizedBox(height: 16),
          Text(message, style: TextStyle(color: Colors.grey.shade600)),
        ],
      ),
    );
  }
}

// --- NEW: /lib/src/features/workspaces/data/workspace_model.dart ---
@immutable
class Workspace {
  final String id;
  final String name;
  final int colorValue;
  final int iconCodepoint;

  const Workspace({
    required this.id,
    required this.name,
    required this.colorValue,
    required this.iconCodepoint,
  });

  Color get color => Color(colorValue);
  IconData get icon => IconData(iconCodepoint, fontFamily: 'MaterialIcons');

  Map<String, dynamic> toMap() => {
    'name': name,
    'colorValue': colorValue,
    'iconCodepoint': iconCodepoint,
  };

  factory Workspace.fromFirestore(DocumentSnapshot<Map<String, dynamic>> doc) {
    final map = doc.data()!;
    return Workspace(
      id: doc.id,
      name: map['name'] ?? 'Untitled Workspace',
      colorValue: map['colorValue'] ?? Colors.grey.value,
      iconCodepoint: map['iconCodepoint'] ?? Icons.work_outline.codePoint,
    );
  }
}

// --- NEW: /lib/src/features/workspaces/workspace_manager.dart ---
class WorkspaceManager extends ChangeNotifier {
  final AuthService _authService;
  final FirestoreService _firestoreService;
  StreamSubscription<List<Workspace>>? _workspacesSubscription;
  List<Workspace> _workspaces = [];
  final _uuid = const Uuid();
  final AppLogger _logger = AppLogger();
  bool _isLoading = true;

  List<Workspace> get workspaces => _workspaces;
  bool get isLoading => _isLoading;

  WorkspaceManager(this._authService, this._firestoreService) {
    _authService.authStateChanges.listen(_handleAuthChange);
    _handleAuthChange(_authService.currentUser);
  }

  @override
  void dispose() {
    _workspacesSubscription?.cancel();
    super.dispose();
  }

  void _handleAuthChange(fb_auth.User? user) {
    _workspacesSubscription?.cancel();
    _workspaces.clear();
    _isLoading = true;
    notifyListeners();

    if (user != null) {
      // Assuming getWorkspacesStream is added to FirestoreService
      _workspacesSubscription = _firestoreService.getWorkspacesStream(user.uid).listen(
            (workspaces) {
          _workspaces = workspaces;
          _isLoading = false;
          notifyListeners();
        },
        onError: (error) {
          _logger.log("WorkspaceManager: Error in stream: $error");
          _isLoading = false;
          notifyListeners();
        },
      );
    } else {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> addWorkspace(String name, Color color, IconData icon) async {
    final user = _authService.currentUser;
    if (user == null) return;
    final newWorkspace = Workspace(
      id: _uuid.v4(),
      name: name.trim(),
      colorValue: color.value,
      iconCodepoint: icon.codePoint,
    );
    // Assuming addWorkspace is added to FirestoreService
    await _firestoreService.addWorkspace(user.uid, newWorkspace);
  }

  Future<void> updateWorkspace(Workspace workspace) async {
    final user = _authService.currentUser;
    if (user == null) return;
    // Assuming updateWorkspace is added to FirestoreService
    await _firestoreService.updateWorkspace(user.uid, workspace);
  }

  Future<void> deleteWorkspace(String workspaceId) async {
    final user = _authService.currentUser;
    if (user == null) return;
    // Assuming deleteWorkspace is added to FirestoreService
    await _firestoreService.deleteWorkspace(user.uid, workspaceId);
  }

  Workspace? getWorkspaceById(String? id) {
    if (id == null) return null;
    try {
      return _workspaces.firstWhere((w) => w.id == id);
    } catch (e) {
      return null;
    }
  }
}

// --- NEW: /lib/src/features/categories/data/category_model.dart ---
// --- NEW: /lib/src/features/categories/data/category_model.dart ---
@immutable
class Category {
  final String id;
  final String name;
  final int colorValue;
  final int iconCodepoint;

  const Category({
    required this.id,
    required this.name,
    this.colorValue = 0xFF757575, // Default: Colors.grey.value
    this.iconCodepoint = 0xe3b2, // Default: Icons.label_outline
  });

  Color get color => Color(colorValue);
  IconData get icon => IconData(iconCodepoint, fontFamily: 'MaterialIcons');

  // Method for JSON serialization
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'colorValue': colorValue,
    'iconCodepoint': iconCodepoint,
  };

  // Factory for creating a new Category instance from a map structure.
  factory Category.fromJson(Map<String, dynamic> json) {
    return Category(
      id: json['id'] as String,
      name: json['name'] as String,
      colorValue: json['colorValue'] as int? ?? 0xFF757575,
      iconCodepoint: json['iconCodepoint'] as int? ?? 0xe3b2,
    );
  }
}


// --- /lib/src/constants/enums.dart ---
enum Priority { high, medium, low }
enum SortOption { dueDate, priority, creationDate, nextSuggestedDate, title }
enum NoteSortOption { lastModified, creationDate, title }
enum SmartFilter { none, overdue, dueToday, highPriority, dailyPriority }
enum TaskStatus { notStarted, inProgress, completed }

// --- /lib/src/data/firestore_service.dart ---
class FirestoreService {
  final FirebaseFirestore _db = FirebaseFirestore.instance;
  final AppLogger _logger = AppLogger();

  // --- Task Methods ---
  Stream<List<Task>> getTasksStream(String userId) {
    return _db.collection(Constants.tasksCollection)
        .where('userId', isEqualTo: userId)
        .where('isArchived', isEqualTo: false) // Exclude archived tasks
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => Task.fromFirestore(doc)).toList())
        .handleError((error) {
      _logger.log("Error in getTasksStream: $error");
      return [];
    });
  }

  Stream<List<Task>> getArchivedTasksStream(String userId) {
    return _db.collection(Constants.tasksCollection)
        .where('userId', isEqualTo: userId)
        .where('isArchived', isEqualTo: true) // Only get archived tasks
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => Task.fromFirestore(doc)).toList())
        .handleError((error) {
      _logger.log("Error in getArchivedTasksStream: $error");
      return [];
    });
  }

  Future<void> addTask(Task task) async {
    try { await _db.collection(Constants.tasksCollection).doc(task.id).set(task.toMap()); } catch (e) { _logger.log("Error adding task: $e"); rethrow; }
  }
  Future<void> updateTask(Task task) async {
    try { await _db.collection(Constants.tasksCollection).doc(task.id).update(task.toMap()); } catch (e) { _logger.log("Error updating task: $e"); rethrow; }
  }
  Future<void> deleteTask(String taskId) async {
    try { await _db.collection(Constants.tasksCollection).doc(taskId).delete(); } catch (e) { _logger.log("Error deleting task: $e"); rethrow; }
  }
  Future<void> deleteTasks(List<String> taskIds) async {
    if (taskIds.isEmpty) return;
    try {
      final batch = _db.batch();
      for (final taskId in taskIds) { batch.delete(_db.collection(Constants.tasksCollection).doc(taskId)); }
      await batch.commit();
    } catch (e) { _logger.log("Error batch deleting tasks: $e"); rethrow; }
  }

  // --- Note Methods ---
  Stream<List<Note>> getNotesStream(String userId) {
    return _db.collection(Constants.notesCollection).where('userId', isEqualTo: userId).snapshots().map((snapshot) => snapshot.docs.map((doc) => Note.fromFirestore(doc)).toList()).handleError((error) {
      _logger.log("Error in getNotesStream: $error");
      return [];
    });
  }
  Future<void> addNote(Note note) async {
    try { await _db.collection(Constants.notesCollection).doc(note.id).set(note.toMap()); } catch (e) { _logger.log("Error adding note: $e"); rethrow; }
  }
  Future<void> updateNote(Note note) async {
    try { await _db.collection(Constants.notesCollection).doc(note.id).update(note.toMap()); } catch (e) { _logger.log("Error updating note: $e"); rethrow; }
  }
  Future<void> deleteNote(String noteId) async {
    try { await _db.collection(Constants.notesCollection).doc(noteId).delete(); } catch (e) { _logger.log("Error deleting note: $e"); rethrow; }
  }

  // --- Linking Methods ---
  Future<void> linkTaskAndNote(String taskId, String noteId) async {
    final taskRef = _db.collection(Constants.tasksCollection).doc(taskId);
    final noteRef = _db.collection(Constants.notesCollection).doc(noteId);
    final batch = _db.batch();

    batch.update(taskRef, { 'linkedNoteIds': FieldValue.arrayUnion([noteId]) });
    batch.update(noteRef, { 'linkedTaskIds': FieldValue.arrayUnion([taskId]) });

    await batch.commit();
  }

  Future<void> unlinkTaskAndNote(String taskId, String noteId) async {
    final taskRef = _db.collection(Constants.tasksCollection).doc(taskId);
    final noteRef = _db.collection(Constants.notesCollection).doc(noteId);
    final batch = _db.batch();

    batch.update(taskRef, { 'linkedNoteIds': FieldValue.arrayRemove([noteId]) });
    batch.update(noteRef, { 'linkedTaskIds': FieldValue.arrayRemove([noteId]) });

    await batch.commit();
  }

  // --- NEW: Workspace Methods ---
  Stream<List<Workspace>> getWorkspacesStream(String userId) {
    return _db.collection(Constants.usersCollection).doc(userId).collection('workspaces').snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => Workspace.fromFirestore(doc)).toList())
        .handleError((error) {
      _logger.log("Error in getWorkspacesStream: $error");
      return [];
    });
  }

  Future<void> addWorkspace(String userId, Workspace workspace) async {
    try {
      await _db.collection(Constants.usersCollection).doc(userId).collection('workspaces').doc(workspace.id).set(workspace.toMap());
    } catch (e) {
      _logger.log("Error adding workspace: $e");
      rethrow;
    }
  }

  Future<void> updateWorkspace(String userId, Workspace workspace) async {
    try {
      await _db.collection(Constants.usersCollection).doc(userId).collection('workspaces').doc(workspace.id).update(workspace.toMap());
    } catch (e) {
      _logger.log("Error updating workspace: $e");
      rethrow;
    }
  }

  Future<void> deleteWorkspace(String userId, String workspaceId) async {
    try {
      await _db.collection(Constants.usersCollection).doc(userId).collection('workspaces').doc(workspaceId).delete();
    } catch (e) {
      _logger.log("Error deleting workspace: $e");
      rethrow;
    }
  }

// --- CATEGORY METHODS REMOVED ---
}

// --- /lib/src/features/settings/theme_manager.dart ---
class ThemeManager extends ChangeNotifier {
  late SharedPreferences _prefs;
  bool _isPrefsInitialized = false;
  ThemeMode _themeMode = ThemeMode.system;
  final AppLogger _logger = AppLogger();

  ThemeMode get themeMode => _themeMode;

  ThemeManager() {
    _initPrefs();
  }

  Future<void> _initPrefs() async {
    if (_isPrefsInitialized) return;
    try {
      _prefs = await SharedPreferences.getInstance();
      _isPrefsInitialized = true;
      await loadTheme();
      _logger.log("ThemeManager: Prefs Initialized.");
    } catch (e) {
      _logger.log("ThemeManager: Error initializing Prefs: $e");
    }
  }

  Future<void> loadTheme() async {
    if (!_isPrefsInitialized) { await _initPrefs(); if (!_isPrefsInitialized) return; }
    try {
      final themeIndex = _prefs.getInt(Constants.themeModeKey);
      _themeMode = (themeIndex != null && themeIndex >= 0 && themeIndex < ThemeMode.values.length) ? ThemeMode.values[themeIndex] : ThemeMode.system;
      _logger.log("ThemeManager: Theme loaded: $_themeMode");
    } catch (e) { _logger.log("ThemeManager: Error loading theme preference: $e"); }
    notifyListeners();
  }

  Future<void> _saveTheme(ThemeMode mode) async {
    if (!_isPrefsInitialized) return;
    try { await _prefs.setInt(Constants.themeModeKey, mode.index); } catch (e) { _logger.log("ThemeManager: Error saving theme preference: $e"); }
  }

  void setThemeMode(ThemeMode mode) {
    if (_themeMode == mode) return;
    _themeMode = mode;
    _saveTheme(mode);
    notifyListeners();
  }
}

// --- /lib/src/features/auth/auth_service.dart ---
class AuthService {
  final fb_auth.FirebaseAuth _firebaseAuth = fb_auth.FirebaseAuth.instance;
  final FirebaseFirestore _db = FirebaseFirestore.instance;
  final AppLogger _logger = AppLogger();

  fb_auth.User? get currentUser => _firebaseAuth.currentUser;
  Stream<fb_auth.User?> get authStateChanges => _firebaseAuth.authStateChanges();

  Future<void> signInWithEmailAndPassword({required String email, required String password}) async {
    await _firebaseAuth.signInWithEmailAndPassword(email: email, password: password);
  }
  Future<void> createUserWithEmailAndPassword({required String email, required String password, required String username}) async {
    fb_auth.UserCredential userCredential = await _firebaseAuth.createUserWithEmailAndPassword(email: email, password: password);
    if (userCredential.user != null) {
      await userCredential.user!.updateDisplayName(username);
      await _db.collection(Constants.usersCollection).doc(userCredential.user!.uid).set({
        'username': username, 'email': email, 'createdAt': Timestamp.now(),
      });
    }
  }
  Future<void> signOut() async { await _firebaseAuth.signOut(); }

  Future<void> changePassword({required String currentPassword, required String newPassword}) async {
    final user = _firebaseAuth.currentUser;
    if (user == null || user.email == null) {
      throw Exception('No user is currently signed in.');
    }
    final cred = fb_auth.EmailAuthProvider.credential(email: user.email!, password: currentPassword);
    await user.reauthenticateWithCredential(cred);
    await user.updatePassword(newPassword);
  }

  Future<void> updateUsername(String newUsername) async {
    final user = _firebaseAuth.currentUser;
    if (user == null) throw Exception('No user is currently signed in.');
    await user.updateDisplayName(newUsername);
    await _db.collection(Constants.usersCollection).doc(user.uid).set(
      {'username': newUsername},
      SetOptions(merge: true),
    );
    await user.reload();
  }


  Future<void> deleteAccount() async {
    try {
      final user = _firebaseAuth.currentUser;
      if (user != null) {
        // NOTE: A cloud function is the recommended way to delete all user data
        // to ensure everything is removed even if the client disconnects.
        // For this app, we delete the user document first.
        await _db.collection(Constants.usersCollection).doc(user.uid).delete();
        await user.delete();
      }
    } on fb_auth.FirebaseAuthException catch (e) {
      _logger.log("Error deleting account: ${e.message}");
      if (e.code == 'requires-recent-login') { throw Exception('This action requires you to sign in again for security.'); }
      rethrow;
    }
  }
}

// --- /lib/src/features/tasks/task_manager.dart ---
class TaskManager extends ChangeNotifier {
  final AuthService _authService;
  final FirestoreService _firestoreService;
  final NotificationService _notificationService;
  late final SharedPreferences _prefs;
  StreamSubscription<List<Task>>? _tasksSubscription;
  List<Task> _tasks = [];
  final _uuid = const Uuid();
  final AppLogger _logger = AppLogger();

  bool _isLoading = true;
  bool _isPrefsInitialized = false;
  Task? _lastArchivedTask;

  // Filtering and Sorting State
  String _filterCategory = "All";
  SortOption _sortOption = SortOption.dueDate;
  String _searchQuery = "";
  bool _showCompleted = true;
  bool _reviewDueFilterActive = false;
  SmartFilter _activeSmartFilter = SmartFilter.none;
  Priority _defaultPriority = Priority.medium;
  int _currentStreak = 0;

  List<Task> get tasks => _filteredTasks;
  List<Task> get _filteredTasks {
    List<Task> r = List.from(_tasks);

    if (_activeSmartFilter != SmartFilter.none) {
      switch (_activeSmartFilter) {
        case SmartFilter.overdue: r = r.where((t) => !t.isComplete && t.dueDate != null && t.dueDate!.isBefore(DateUtils.dateOnly(DateTime.now()))).toList(); break;
        case SmartFilter.dueToday: r = r.where((t) => !t.isComplete && t.dueDate != null && DateUtils.isSameDay(t.dueDate, DateTime.now())).toList(); break;
        case SmartFilter.highPriority: r = r.where((t) => !t.isComplete && t.priority == Priority.high).toList(); break;
        case SmartFilter.dailyPriority: r = r.where((t) => !t.isComplete && t.isDailyPriority).toList(); break;
        case SmartFilter.none: break;
      }
    } else if (_reviewDueFilterActive) {
      r = r.where((t) => t.isReviewDue).toList();
    } else {
      if (_filterCategory != "All") { r = r.where((t) => t.categories?.contains(_filterCategory) ?? false).toList(); }
      if (_searchQuery.isNotEmpty) { r = r.where((t) => t.title.toLowerCase().contains(_searchQuery) || (t.description?.toLowerCase().contains(_searchQuery) ?? false)).toList(); }
      if (!_showCompleted) { r = r.where((t) => !t.isComplete).toList(); }
    }
    r.sort((a, b) {
      if (a.isDailyPriority != b.isDailyPriority) return a.isDailyPriority ? -1 : 1;
      final aC = a.isComplete, bC = b.isComplete;
      if(aC != bC) return aC ? 1: -1;

      switch (_sortOption) {
        case SortOption.dueDate: final aD = a.dueDate, bD = b.dueDate; if (aD == bD) return 0; if (aD == null) return 1; if (bD == null) return -1; return aD.compareTo(bD);
        case SortOption.priority: final pC = a.priority.index.compareTo(b.priority.index); if (pC != 0) return pC; final aD = a.dueDate, bD = b.dueDate; if (aD == bD) return 0; if (aD == null) return 1; if (bD == null) return -1; return aD.compareTo(bD);
        case SortOption.creationDate: return b.creationTimestamp.compareTo(a.creationTimestamp);
        case SortOption.nextSuggestedDate: if (!aC) { final aD = a.dueDate, bD = b.dueDate; if (aD == bD) return 0; if (aD == null) return 1; if (bD == null) return -1; return aD.compareTo(bD); } final aS = a.nextSuggestedDate, bS = b.nextSuggestedDate; if (aS == bS) return 0; if (aS == null) return 1; if (bS == null) return -1; return aS.compareTo(bS);
        case SortOption.title: return a.title.toLowerCase().compareTo(b.title.toLowerCase());
      }
    });
    return r;
  }
  List<Task> get originalTasks => List.unmodifiable(_tasks);
  bool get isLoading => _isLoading;
  Priority get defaultPriority => _defaultPriority;
  String get filterCategory => _filterCategory;
  SortOption get sortOption => _sortOption;
  String get searchQuery => _searchQuery;
  bool get showCompleted => _showCompleted;
  bool get reviewDueFilterActive => _reviewDueFilterActive;
  SmartFilter get activeSmartFilter => _activeSmartFilter;
  int get overdueCount => _tasks.where((t) => !t.isComplete && t.dueDate != null && t.dueDate!.isBefore(DateUtils.dateOnly(DateTime.now()))).length;
  int get dueTodayCount => _tasks.where((t) => !t.isComplete && t.dueDate != null && DateUtils.isSameDay(t.dueDate, DateTime.now())).length;
  int get highPriorityCount => _tasks.where((t) => !t.isComplete && t.priority == Priority.high).length;
  int get dailyPriorityCount => _tasks.where((t) => !t.isComplete && t.isDailyPriority).length;
  int get highPriorityTaskCount => _tasks.where((t) => t.priority == Priority.high).length;
  int get mediumPriorityTaskCount => _tasks.where((t) => t.priority == Priority.medium).length;
  int get lowPriorityTaskCount => _tasks.where((t) => t.priority == Priority.low).length;
  int get reviewDueCount => _tasks.where((task) => task.isReviewDue).length;
  int get totalTaskCount => _tasks.length;
  int get completedTaskCount => _tasks.where((t) => t.isComplete).length;
  int get inProgressTaskCount => _tasks.where((t) => t.status == TaskStatus.inProgress).length;
  int get completedThisWeekCount { final now = DateTime.now(); final startOfWeek = now.subtract(Duration(days: now.weekday - 1)); final startOfThisWeek = DateUtils.dateOnly(startOfWeek); return _tasks.where((t) => t.isComplete && t.completionTimestamp != null && !t.completionTimestamp!.isBefore(startOfThisWeek)).length; }
  Map<String, int> get weeklyCompletionData {
    final Map<String, int> data = {'Mon': 0, 'Tue': 0, 'Wed': 0, 'Thu': 0, 'Fri': 0, 'Sat': 0, 'Sun': 0};
    final now = DateTime.now();
    final startOfWeek = DateUtils.dateOnly(now.subtract(Duration(days: now.weekday - 1)));
    final endOfWeek = startOfWeek.add(const Duration(days: 7));

    _tasks.where((t) => t.isComplete && t.completionTimestamp != null && t.completionTimestamp!.isAfter(startOfWeek) && t.completionTimestamp!.isBefore(endOfWeek))
        .forEach((t) {
      final day = DateFormat('E').format(t.completionTimestamp!);
      data.update(day, (value) => value + 1);
    });
    return data;
  }
  String get mostProductiveDay { if (completedTaskCount == 0) return "N/A"; final Map<int, int> dayCounts = {}; _tasks.where((t) => t.isComplete && t.completionTimestamp != null).forEach((t) { dayCounts.update(t.completionTimestamp!.weekday, (value) => value + 1, ifAbsent: () => 1); }); if (dayCounts.isEmpty) return "N/A"; final mostProductive = dayCounts.entries.reduce((a, b) => a.value > b.value ? a : b); return DateFormat('EEEE').format(DateTime(2023, 1, 1 + mostProductive.key -1)); }
  Set<String> get allCategories { final Set<String> categories = {"All"}; for (final task in _tasks) { if (task.categories != null) { categories.addAll(task.categories!); } } return categories; }
  int get totalFocusTime { return _tasks.fold(0, (sum, task) => sum + task.totalFocusTime); }
  int get totalFocusSessions { return _tasks.fold(0, (sum, task) => sum + task.focusSessions); }
  int get currentStreak => _currentStreak;

  set filterCategory(String category) { if (_filterCategory != category) { _filterCategory = category; _activeSmartFilter = SmartFilter.none; if (category != 'All' && _reviewDueFilterActive) _reviewDueFilterActive = false; notifyListeners(); } }
  set sortOption(SortOption option) { if (_sortOption != option) { _sortOption = option; notifyListeners(); } }
  set searchQuery(String query) { final newQuery = query.toLowerCase(); if (_searchQuery != newQuery) { _searchQuery = newQuery; _activeSmartFilter = SmartFilter.none; if (query.isNotEmpty && _reviewDueFilterActive) _reviewDueFilterActive = false; notifyListeners(); } }
  set showCompleted(bool v) { if (_showCompleted != v) { _showCompleted = v; if (!v && _reviewDueFilterActive) _reviewDueFilterActive = false; notifyListeners(); } }
  set reviewDueFilterActive(bool v) { if (_reviewDueFilterActive != v) { _reviewDueFilterActive = v; if (v) { _activeSmartFilter = SmartFilter.none; _showCompleted = true; _filterCategory = "All"; _searchQuery = ""; _sortOption = SortOption.nextSuggestedDate; } notifyListeners(); } }
  void applySmartFilter(SmartFilter filter) { if (_activeSmartFilter == filter) { _activeSmartFilter = SmartFilter.none; } else { _activeSmartFilter = filter; _reviewDueFilterActive = false; _filterCategory = "All"; } notifyListeners(); }

  TaskManager(this._authService, this._firestoreService, this._notificationService) {
    _initAndLoadData();
    _authService.authStateChanges.listen(_handleAuthChange);
  }

  @override void dispose() { _tasksSubscription?.cancel(); super.dispose(); }

  void _handleAuthChange(fb_auth.User? user) {
    _tasksSubscription?.cancel();
    _tasks.clear();
    _reviewDueFilterActive = false;
    _activeSmartFilter = SmartFilter.none;
    _isLoading = true;
    notifyListeners();

    if (user != null) {
      _logger.log("TaskManager: Auth change for user: ${user.uid}");
      _tasksSubscription = _firestoreService.getTasksStream(user.uid).listen((tasks) {
        _tasks = tasks; _isLoading = false; notifyListeners();
      }, onError: (error) {
        _logger.log("TaskManager: Error in tasks stream: $error");
        _isLoading = false; notifyListeners();
      });
    } else {
      _logger.log("TaskManager: No user signed in. Clearing tasks.");
      _isLoading = false; notifyListeners();
    }
  }

  Future<void> _initAndLoadData() async {
    await _initPrefs();
    await _loadDefaultPriority();
    _loadStreak();
    _handleAuthChange(_authService.currentUser);
  }

  Future<void> _initPrefs() async { if (!_isPrefsInitialized) { _prefs = await SharedPreferences.getInstance(); _isPrefsInitialized = true; } }
  Future<void> _loadDefaultPriority() async { final usageData = _prefs.getString(Constants.priorityUsageKey); if (usageData != null) { try { final usageMap = Map<String, int>.from(jsonDecode(usageData) as Map); if (usageMap.isNotEmpty) { final mostUsed = usageMap.entries.reduce((a, b) => a.value > b.value ? a : b); _defaultPriority = Priority.values[int.parse(mostUsed.key)]; } } catch (e) { _logger.log("Error loading/parsing priority usage: $e"); } } notifyListeners(); }
  Future<void> setDefaultPriority(Priority newPriority) async { _defaultPriority = newPriority; notifyListeners(); }
  Future<void> _trackPriorityUsage(Priority priority) async { final usageJson = _prefs.getString(Constants.priorityUsageKey) ?? '{}'; final usageMap = Map<String, int>.from(jsonDecode(usageJson) as Map); final key = priority.index.toString(); usageMap[key] = (usageMap[key] ?? 0) + 1; await _prefs.setString(Constants.priorityUsageKey, jsonEncode(usageMap)); await _loadDefaultPriority(); }
  Duration _calculateSrsInterval(int level) { if (level <= 0) return const Duration(days: 1); if (level == 1) return const Duration(days: 3); if (level == 2) return const Duration(days: 7); if (level == 3) return const Duration(days: 16); if (level == 4) return const Duration(days: 35); double f = 2.1; int d = (35 * pow(f, level - 4)).round().clamp(1, 3650); return Duration(days: d); }
  DateTime _getAgainDate() { return DateUtils.dateOnly(DateTime.now()).add(const Duration(days: 1)); }

  void _loadStreak() {
    _currentStreak = _prefs.getInt(Constants.currentStreakKey) ?? 0;
    final lastDateStr = _prefs.getString(Constants.lastCompletionDateKey);
    if (lastDateStr != null) {
      final lastDate = DateTime.parse(lastDateStr);
      final today = DateUtils.dateOnly(DateTime.now());
      if (today.isAfter(lastDate.add(const Duration(days: 1)))) {
        _currentStreak = 0;
        _prefs.setInt(Constants.currentStreakKey, 0);
      }
    }
    notifyListeners();
  }

  Future<void> _updateStreak() async {
    final today = DateUtils.dateOnly(DateTime.now());
    final lastDateStr = _prefs.getString(Constants.lastCompletionDateKey);

    if (lastDateStr == null) {
      _currentStreak = 1;
    } else {
      final lastDate = DateTime.parse(lastDateStr);
      if (isSameDay(today, lastDate)) {
        return;
      } else if (isSameDay(today, lastDate.add(const Duration(days: 1)))) {
        _currentStreak++;
      } else {
        _currentStreak = 1;
      }
    }
    await _prefs.setInt(Constants.currentStreakKey, _currentStreak);
    await _prefs.setString(Constants.lastCompletionDateKey, today.toIso8601String());
    notifyListeners();
  }

  Future<void> addTask({ required String title, String? description, DateTime? dueDate, Priority priority = Priority.medium, List<String>? categories, List<Subtask>? subtasks, RecurrenceRule? recurrence, List<Attachment>? attachments }) async {
    final user = _authService.currentUser; if (user == null) return;
    await _trackPriorityUsage(priority);
    final newTask = Task(id: _uuid.v4(), userId: user.uid, title: title.trim(), description: description?.trim(), dueDate: dueDate, priority: priority, creationTimestamp: DateTime.now(), categories: categories, subtasks: subtasks ?? [], recurrence: recurrence, attachments: attachments ?? []);
    try {
      await _firestoreService.addTask(newTask);
      await _scheduleNotificationsForTask(newTask);
    } catch (e) { _logger.log("TaskManager: Error adding task ${newTask.id}: $e"); rethrow; }
  }

  Future<void> updateTask(Task updatedTask) async {
    if (_authService.currentUser == null) return;
    try {
      await _cancelNotificationsForTask(updatedTask);
      await _firestoreService.updateTask(updatedTask);
      await _scheduleNotificationsForTask(updatedTask);
    } catch (e) { _logger.log("TaskManager: Error updating task ${updatedTask.id}: $e"); rethrow; }
  }

  // --- /lib/src/features/tasks/task_manager.dart ---

// REPLACE the existing permanentlyDeleteTask function with this one:

  // In your TaskManager class

  Future<void> permanentlyDeleteTask(String taskId) async {
    try {
      final docRef = FirebaseFirestore.instance.collection(Constants.tasksCollection).doc(taskId);
      final doc = await docRef.get();

      if (!doc.exists) {
        _logger.log("Task with ID $taskId not found for permanent deletion.");
        return;
      }

      final taskToDelete = Task.fromFirestore(doc as DocumentSnapshot<Map<String, dynamic>>);

      // Only try to delete local files if NOT on web
      if (!kIsWeb) {
        for (var attachment in taskToDelete.attachments) {
          try {
            final file = File(attachment.localPath);
            if (await file.exists()) {
              await file.delete();
            }
          } catch(e) {
            _logger.log("Error deleting local attachment ${attachment.localPath}: $e");
          }
        }
      }

      await _cancelNotificationsForTask(taskToDelete);
      await _firestoreService.deleteTask(taskId);

    } catch (e) {
      _logger.log("Error during permanent deletion of task $taskId: $e");
      rethrow;
    }
  }

  Future<void> archiveTask(String taskId) async {
    final index = _tasks.indexWhere((task) => task.id == taskId);
    if (index != -1) {
      _lastArchivedTask = _tasks[index];
      final updatedTask = _tasks[index].copyWith(isArchived: true);
      await updateTask(updatedTask);
      Future.delayed(const Duration(seconds: 5), () { if (_lastArchivedTask?.id == taskId) _lastArchivedTask = null; });
    }
  }

  Future<void> unarchiveTask(String taskId) async {
    final docRef = FirebaseFirestore.instance.collection(Constants.tasksCollection).doc(taskId);
    final doc = await docRef.get();
    if(doc.exists) {
      final task = Task.fromFirestore(doc as DocumentSnapshot<Map<String, dynamic>>);
      final updatedTask = task.copyWith(isArchived: false);
      await updateTask(updatedTask);
      _lastArchivedTask = null;
    }
  }

  bool canUndoArchive() => _lastArchivedTask != null;
  Future<void> undoArchiveTask() async {
    if (canUndoArchive()) {
      final taskToRestore = _lastArchivedTask!;
      try {
        await unarchiveTask(taskToRestore.id);
      } catch (e) {
        _logger.log("TaskManager: Error restoring task from archive ${taskToRestore.id}: $e");
      } finally {
        _lastArchivedTask = null;
      }
    }
  }

  Future<void> updateTaskStatus(String taskId, TaskStatus newStatus) async {
    final index = _tasks.indexWhere((t) => t.id == taskId);
    if (index != -1) {
      final currentTask = _tasks[index]; if (currentTask.status == newStatus) return;
      Task updatedTask = currentTask.copyWith(status: newStatus);

      if (newStatus == TaskStatus.completed) {
        HapticFeedback.mediumImpact();
        await _updateStreak();
        await _cancelNotificationsForTask(currentTask);

        if (currentTask.recurrence != null && currentTask.dueDate != null) {
          final nextDueDate = _calculateNextRecurrence(currentTask.dueDate!, currentTask.recurrence!);
          final nextTask = currentTask.copyWith(
            id: _uuid.v4(),
            dueDate: nextDueDate,
            status: TaskStatus.notStarted,
            completionTimestamp: () => null,
            creationTimestamp: DateTime.now(),
            isDailyPriority: false,
          );
          await addTask(
            title: nextTask.title, description: nextTask.description, dueDate: nextTask.dueDate,
            priority: nextTask.priority, categories: nextTask.categories,
            subtasks: nextTask.subtasks.map((s) => Subtask(id: _uuid.v4(), title: s.title, isCompleted: false)).toList(),
            recurrence: nextTask.recurrence,
          );
          updatedTask = updatedTask.copyWith(recurrence: null, setRecurrenceNull: true);
        }

        final currentSrsLevel = currentTask.srsLevel;
        final interval = _calculateSrsInterval(currentSrsLevel);
        var nextReviewDate = DateTime.now().add(interval);
        if (interval >= const Duration(days: 1) && DateUtils.isSameDay(nextReviewDate, DateTime.now())) { nextReviewDate = DateUtils.dateOnly(DateTime.now()).add(const Duration(days: 1)); }
        updatedTask = updatedTask.copyWith(srsLevel: currentSrsLevel + 1, nextSuggestedDate: nextReviewDate, completionTimestamp: () => DateTime.now());
      } else {
        updatedTask = updatedTask.copyWith(completionTimestamp: () => null, nextSuggestedDate: null, setNextSuggestedDateNull: true);
      }
      await updateTask(updatedTask);
    }
  }

  Future<void> _scheduleNotificationsForTask(Task task) async {
    if (task.dueDate == null || task.isComplete || task.isArchived) return;

    final dueDay = task.dueDate!;

    final dueDayNotificationTime = DateTime(dueDay.year, dueDay.month, dueDay.day, 9, 0);
    await _notificationService.scheduleTaskReminder(
      task.dueDayNotificationId,
      "Task Due Today: ${task.title}",
      "Don't forget to complete it!",
      dueDayNotificationTime,
    );

    final thirtyMinReminderTime = dueDay.subtract(const Duration(minutes: 30));
    await _notificationService.scheduleTaskReminder(
      task.thirtyMinNotificationId,
      "Reminder: ${task.title}",
      "Due in 30 minutes at ${DateFormat.jm().format(dueDay)}",
      thirtyMinReminderTime,
    );
  }

  Future<void> _cancelNotificationsForTask(Task task) async {
    await _notificationService.cancelNotification(task.dueDayNotificationId);
    await _notificationService.cancelNotification(task.thirtyMinNotificationId);
  }

  DateTime _calculateNextRecurrence(DateTime currentDueDate, RecurrenceRule rule) {
    switch (rule.frequency) {
      case RecurrenceFrequency.daily: return currentDueDate.add(Duration(days: rule.interval));
      case RecurrenceFrequency.weekly: return currentDueDate.add(Duration(days: 7 * rule.interval));
      case RecurrenceFrequency.monthly:
        var d = DateTime(currentDueDate.year, currentDueDate.month + rule.interval, currentDueDate.day, currentDueDate.hour, currentDueDate.minute);
        if (d.day != currentDueDate.day) {
          return DateTime(d.year, d.month + 1, 0, currentDueDate.hour, currentDueDate.minute);
        }
        return d;
    }
  }

  Future<void> archiveAllCompletedTasks() async {
    if (_authService.currentUser == null) return;
    final completedTasks = _tasks.where((task) => task.isComplete).toList();
    if (completedTasks.isEmpty) return;

    final batch = FirebaseFirestore.instance.batch();
    for (final task in completedTasks) {
      final taskRef = FirebaseFirestore.instance.collection(Constants.tasksCollection).doc(task.id);
      batch.update(taskRef, {'isArchived': true});
    }
    await batch.commit();
  }

  Future<void> markTaskGood(String taskId) async {
    final index = _tasks.indexWhere((t) => t.id == taskId);
    if (index != -1) {
      final currentTask = _tasks[index]; if (!currentTask.isComplete) return;
      final currentSrsLevel = currentTask.srsLevel;
      final interval = _calculateSrsInterval(currentSrsLevel);
      final nextReviewDate = DateTime.now().add(interval);
      final updatedTask = currentTask.copyWith(srsLevel: currentSrsLevel + 1, nextSuggestedDate: nextReviewDate);
      await updateTask(updatedTask);
    }
  }

  Future<void> markTaskAgain(String taskId) async {
    final index = _tasks.indexWhere((t) => t.id == taskId);
    if (index != -1) {
      final currentTask = _tasks[index]; if (!currentTask.isComplete) return;
      final nextReviewDate = _getAgainDate();
      final updatedTask = currentTask.copyWith(srsLevel: 0, nextSuggestedDate: nextReviewDate);
      await updateTask(updatedTask);
    }
  }

  Future<void> saveTaskDraft({String? title, String? description, String? categories, DateTime? dueDate, Priority? priority}) async { await _initPrefs(); final draft = {'title': title, 'description': description, 'categories': categories, 'dueDate': dueDate?.toIso8601String(), 'priority': priority?.index}; await _prefs.setString(Constants.taskDraftKey, jsonEncode(draft)); }
  Future<Map<String, dynamic>?> loadTaskDraft() async { await _initPrefs(); final draftString = _prefs.getString(Constants.taskDraftKey); return draftString != null ? jsonDecode(draftString) as Map<String, dynamic> : null; }
  Future<void> clearTaskDraft() async { await _initPrefs(); await _prefs.remove(Constants.taskDraftKey); }

  Future<void> setDailyPriorities(List<String> priorityTaskIds) async {
    if (_authService.currentUser == null) return;
    final batch = FirebaseFirestore.instance.batch();
    for (final task in _tasks) {
      if (task.isDailyPriority && !priorityTaskIds.contains(task.id)) {
        final taskRef = FirebaseFirestore.instance.collection(Constants.tasksCollection).doc(task.id);
        batch.update(taskRef, {'isDailyPriority': false});
      }
    }
    for (final taskId in priorityTaskIds) {
      final taskRef = FirebaseFirestore.instance.collection(Constants.tasksCollection).doc(taskId);
      batch.update(taskRef, {'isDailyPriority': true});
    }
    await batch.commit();
  }
}

// --- /lib/src/features/notes/note_manager.dart ---
class NoteManager extends ChangeNotifier {
  final AuthService _authService;
  final FirestoreService _firestoreService;
  StreamSubscription<List<Note>>? _notesSubscription;
  List<Note> _notes = [];
  final _uuid = const Uuid();
  final AppLogger _logger = AppLogger();

  bool _isLoading = true;
  String _searchQuery = "";
  NoteSortOption _sortOption = NoteSortOption.lastModified;

  bool get isLoading => _isLoading;
  String get searchQuery => _searchQuery;
  NoteSortOption get sortOption => _sortOption;
  int get totalNoteCount => _notes.length;
  List<Note> get originalNotes => List.unmodifiable(_notes);

  List<Note> get notes {
    List<Note> r = List.from(_notes);
    if (_searchQuery.isNotEmpty) {
      r = r.where((n) {
        return n.title.toLowerCase().contains(_searchQuery) || n.content.toLowerCase().contains(_searchQuery);
      }).toList();
    }
    r.sort((a, b) {
      if (a.isPinned && !b.isPinned) return -1;
      if (!a.isPinned && b.isPinned) return 1;
      switch (_sortOption) {
        case NoteSortOption.lastModified: return b.lastModifiedTimestamp.compareTo(a.lastModifiedTimestamp);
        case NoteSortOption.creationDate: return b.creationTimestamp.compareTo(a.creationTimestamp);
        case NoteSortOption.title: return a.title.toLowerCase().compareTo(b.title.toLowerCase());
      }
    });
    return r;
  }

  set searchQuery(String query) {
    final newQuery = query.toLowerCase();
    if (_searchQuery != newQuery) { _searchQuery = newQuery; notifyListeners(); }
  }
  set sortOption(NoteSortOption option) {
    if (_sortOption != option) { _sortOption = option; notifyListeners(); }
  }

  NoteManager(this._authService, this._firestoreService) {
    _authService.authStateChanges.listen(_handleAuthChange);
    _handleAuthChange(_authService.currentUser);
  }

  @override void dispose() { _notesSubscription?.cancel(); super.dispose(); }

  void _handleAuthChange(fb_auth.User? user) {
    _notesSubscription?.cancel();
    _notes.clear(); _isLoading = true; notifyListeners();
    if (user != null) {
      _notesSubscription = _firestoreService.getNotesStream(user.uid).listen((notes) {
        _notes = notes; _isLoading = false; notifyListeners();
      }, onError: (error) {
        _isLoading = false; notifyListeners();
      });
    } else {
      _isLoading = false; notifyListeners();
    }
  }

  Note? getNoteById(String id) {
    try { return _notes.firstWhere((note) => note.id == id); }
    catch (e) { return null; }
  }

  Future<String> createNewNote() async {
    final user = _authService.currentUser;
    if (user == null) throw Exception("User not signed in");

    final now = DateTime.now();
    final newNote = Note(
        id: _uuid.v4(), userId: user.uid, title: "New Note", content: "",
        creationTimestamp: now, lastModifiedTimestamp: now
    );
    await _firestoreService.addNote(newNote);
    return newNote.id;
  }

  Future<void> updateNote(Note updatedNote) async {
    try { await _firestoreService.updateNote(updatedNote); }
    catch (e) { _logger.log("NoteManager: Error updating note ${updatedNote.id}: $e"); rethrow; }
  }

  // In your NoteManager class

  Future<void> deleteNote(String noteId) async {
    final noteToDelete = _notes.firstWhere((n) => n.id == noteId, orElse: () => throw Exception("Note not found"));

    // Only try to delete local files if NOT on web
    if (!kIsWeb) {
      for (var attachment in noteToDelete.attachments) {
        try {
          final file = File(attachment.localPath);
          if (await file.exists()) { await file.delete(); }
        } catch(e) { _logger.log("Error deleting local attachment ${attachment.localPath}: $e"); }
      }
    }

    await _firestoreService.deleteNote(noteId);
  }
}

// --- NEW: /lib/src/features/categories/category_manager.dart ---
// --- NEW: /lib/src/features/categories/category_manager.dart ---
// REWRITTEN FOR LOCAL STORAGE
class CategoryManager extends ChangeNotifier {
  final AuthService _authService;
  late SharedPreferences _prefs;
  bool _isPrefsInitialized = false;

  List<Category> _categories = [];
  final AppLogger _logger = AppLogger();
  bool _isLoading = true;

  List<Category> get categories => _categories;
  bool get isLoading => _isLoading;

  CategoryManager(this._authService) {
    _authService.authStateChanges.listen(_handleAuthChange);
    _initManager();
  }

  Future<void> _initManager() async {
    await _initPrefs();
    _handleAuthChange(_authService.currentUser);
  }

  Future<void> _initPrefs() async {
    if (_isPrefsInitialized) return;
    _prefs = await SharedPreferences.getInstance();
    _isPrefsInitialized = true;
  }

  String get _userCategoriesKey {
    final userId = _authService.currentUser?.uid;
    return 'userCategories_$userId';
  }

  void _handleAuthChange(fb_auth.User? user) {
    _categories.clear();
    _isLoading = true;
    notifyListeners();

    if (user != null) {
      _loadCategories();
    } else {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> _loadCategories() async {
    if (!_isPrefsInitialized) await _initPrefs();
    try {
      final List<String> categoriesJson =
          _prefs.getStringList(_userCategoriesKey) ?? [];
      _categories = categoriesJson
          .map((jsonString) =>
          Category.fromJson(jsonDecode(jsonString) as Map<String, dynamic>))
          .toList();
      _logger.log("Loaded ${_categories.length} categories from local storage.");
    } catch (e) {
      _logger.log("Error loading categories from local storage: $e");
      _categories = [];
    }
    _isLoading = false;
    notifyListeners();
  }

  Future<void> _saveCategories() async {
    if (!_isPrefsInitialized) await _initPrefs();
    try {
      final List<String> categoriesJson =
      _categories.map((category) => jsonEncode(category.toJson())).toList();
      await _prefs.setStringList(_userCategoriesKey, categoriesJson);
      _logger.log("Saved ${_categories.length} categories to local storage.");
    } catch (e) {
      _logger.log("Error saving categories to local storage: $e");
    }
  }

  /// **ENHANCED: Now accepts a full Category object to save all its data.**
  Future<void> addCategory(Category newCategory) async {
    final trimmedName = newCategory.name.trim();
    if (trimmedName.isEmpty ||
        _categories.any(
                (c) => c.name.toLowerCase() == trimmedName.toLowerCase())) {
      return;
    }
    _categories.add(newCategory);
    await _saveCategories();
    notifyListeners();
  }

  /// **ENHANCED: Now accepts a full Category object to update all its data.**
  Future<void> updateCategory(Category updatedCategory) async {
    final index =
    _categories.indexWhere((c) => c.id == updatedCategory.id);
    if (index != -1) {
      _categories[index] = updatedCategory;
      await _saveCategories();
      notifyListeners();
    }
  }

  Future<void> deleteCategory(String categoryId) async {
    _categories.removeWhere((c) => c.id == categoryId);
    await _saveCategories();
    notifyListeners();
  }
}

// --- /lib/main.dart (Top Level) ---
// --- /lib/main.dart (Top Level) ---
Future<void> _configureLocalTimeZone() async {
  final AppLogger logger = AppLogger();
  tz.initializeTimeZones();
  try {
    final String localTimezone = tz.local.name;
    tz.setLocalLocation(tz.getLocation(localTimezone));
    logger.log("Timezone configured for: $localTimezone");
  } catch(e) {
    logger.log("Could not configure local timezone: $e");
  }
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await _configureLocalTimeZone();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  // --- START: CRASHLYTICS SETUP ---
  // Pass all uncaught "fatal" errors from the framework to Crashlytics
  FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;

  // Pass all uncaught asynchronous errors that aren't handled by the Flutter framework to Crashlytics
  PlatformDispatcher.instance.onError = (error, stack) {
    FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);
    return true;
  };
  // --- END: CRASHLYTICS SETUP ---

  const bool isDebugMode = false; // Set this to `false` for production builds

  if (isDebugMode) {
    print("App Check is using the DEBUG provider.");
    await FirebaseAppCheck.instance.activate(
      androidProvider: AndroidProvider.debug,
      appleProvider: AppleProvider.debug,
    );
  }
  else {
    print("App Check is using PRODUCTION providers (Play Integrity/App Attest).");
    await FirebaseAppCheck.instance.activate(
      androidProvider: AndroidProvider.playIntegrity,
      appleProvider: AppleProvider.appAttest,
    );
  }
  AppLogger().log("Firebase initialized successfully.");

  final authService = AuthService();
  final firestoreService = FirestoreService();
  final themeManager = ThemeManager();
  final notificationService = NotificationService();
  await notificationService.init();
  await notificationService.requestPermissions();

  notificationService.showPersistentDashboardNotification();

  runApp(
    MultiProvider(
      providers: [
        Provider<AuthService>.value(value: authService),
        Provider<FirestoreService>.value(value: firestoreService),
        Provider<NotificationService>.value(value: notificationService),
        Provider<SharedPreferences>.value(
            value: await SharedPreferences.getInstance()),
        ChangeNotifierProvider<ThemeManager>.value(value: themeManager),
        ChangeNotifierProvider<TaskManager>(
            create: (context) => TaskManager(
              context.read<AuthService>(),
              context.read<FirestoreService>(),
              context.read<NotificationService>(),
            )),
        ChangeNotifierProvider<NoteManager>(
            create: (context) => NoteManager(
                context.read<AuthService>(), context.read<FirestoreService>())),
        ChangeNotifierProvider<WorkspaceManager>(
            create: (context) => WorkspaceManager(
                context.read<AuthService>(), context.read<FirestoreService>())),
        ChangeNotifierProvider<CategoryManager>(
            create: (context) => CategoryManager(
              context.read<AuthService>(),
            )),
      ],
      child: const NisanApp(),
    ),
  );
}

// --- /lib/src/app.dart ---
class NisanApp extends StatelessWidget {
  const NisanApp({super.key});

  @override
  Widget build(BuildContext context) {
    return Consumer<ThemeManager>(
      builder: (ctx, themeManager, child) {
        final lightScheme = ColorScheme.fromSeed(seedColor: Colors.teal, brightness: Brightness.light);
        final baseTheme = ThemeData(useMaterial3: true, snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8))));
        final auroraDarkTheme = ThemeData(
            useMaterial3: true,
            brightness: Brightness.dark,
            colorScheme: ColorScheme.dark(primary: Colors.cyanAccent.shade400, onPrimary: const Color(0xFF003738), primaryContainer: const Color(0xFF004F50), onPrimaryContainer: Colors.cyanAccent.shade100, secondary: Colors.purpleAccent.shade100, onSecondary: const Color(0xFF4A005F), secondaryContainer: const Color(0xFF642A78), onSecondaryContainer: Colors.purpleAccent.shade100, tertiary: Colors.tealAccent.shade100, onTertiary: const Color(0xFF003738), tertiaryContainer: const Color(0xFF004F50), onTertiaryContainer: Colors.tealAccent.shade100, background: const Color(0xFF10121a), onBackground: const Color(0xFFE2E2E6), surface: const Color(0xFF1c1e27), onSurface: const Color(0xFFE2E2E6), surfaceVariant: const Color(0xFF3F4849), onSurfaceVariant: const Color(0xFFBFC8C9), outline: const Color(0xFF899293), error: const Color(0xFFFFB4AB), onError: const Color(0xFF690005), errorContainer: const Color(0xFF93000A), onErrorContainer: const Color(0xFFFFDAD6)),
            scaffoldBackgroundColor: const Color(0xFF10121a),
            appBarTheme: AppBarTheme(backgroundColor: const Color(0xFF1A1C25), elevation: 0, iconTheme: IconThemeData(color: Colors.cyanAccent.shade100), titleTextStyle: TextStyle(fontSize: 20, fontWeight: FontWeight.w600, color: Colors.grey.shade200)),
            cardTheme: CardThemeData(elevation: 0, color: const Color(0xFF1c1e27), shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12), side: BorderSide(color: Colors.white.withOpacity(0.1), width: 1.0))),
            floatingActionButtonTheme: FloatingActionButtonThemeData(backgroundColor: Colors.cyanAccent.shade400, foregroundColor: const Color(0xFF003738), elevation: 4, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16))),
            elevatedButtonTheme: ElevatedButtonThemeData(style: ElevatedButton.styleFrom(backgroundColor: Colors.cyanAccent.shade400, foregroundColor: const Color(0xFF003738), shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)), padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 14), textStyle: const TextStyle(fontWeight: FontWeight.bold))),
            outlinedButtonTheme: OutlinedButtonThemeData(style: OutlinedButton.styleFrom(foregroundColor: Colors.cyanAccent.shade200, side: BorderSide(color: Colors.cyanAccent.shade200.withOpacity(0.7)), shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)), padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 14))),
            textButtonTheme: TextButtonThemeData(style: TextButton.styleFrom(foregroundColor: Colors.cyanAccent.shade100)),
            snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)), backgroundColor: const Color(0xFF2A2930), contentTextStyle: TextStyle(color: Colors.grey.shade200), actionTextColor: Colors.cyanAccent.shade200),
            dividerTheme: DividerThemeData(space: 1, thickness: 1, color: Colors.white.withOpacity(0.15)),
            popupMenuTheme: PopupMenuThemeData(color: const Color(0xFF2A2930), shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)), textStyle: TextStyle(color: Colors.grey.shade200)),
            dialogTheme: DialogThemeData(backgroundColor: const Color(0xFF1c1e27), shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16))),
            inputDecorationTheme: InputDecorationTheme(filled: true, fillColor: Colors.black.withOpacity(0.3), border: OutlineInputBorder(borderRadius: BorderRadius.circular(10), borderSide: BorderSide.none), focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(10), borderSide: BorderSide(color: Colors.cyanAccent.shade400, width: 2)), labelStyle: TextStyle(color: Colors.grey.shade400), hintStyle: TextStyle(color: Colors.grey.shade600)),
            chipTheme: ChipThemeData(backgroundColor: Colors.cyanAccent.withOpacity(0.1), labelStyle: TextStyle(color: Colors.cyanAccent.shade100), side: BorderSide.none, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8))),
            expansionTileTheme: ExpansionTileThemeData(textColor: Colors.cyanAccent.shade100, iconColor: Colors.cyanAccent.shade200, collapsedIconColor: Colors.grey.shade400)
        );

        return MaterialApp(
          title: 'NisanApp',
          themeMode: themeManager.themeMode,
          theme: baseTheme.copyWith(colorScheme: lightScheme, appBarTheme: AppBarTheme(backgroundColor: lightScheme.surfaceContainerHighest), dividerTheme: DividerThemeData(space: 1, thickness: 1, color: Colors.grey.shade300)),
          darkTheme: auroraDarkTheme,
          initialRoute: Constants.splashRoute,
          routes: {
            Constants.splashRoute: (_) => const SplashScreen(),
            Constants.onboardingRoute: (_) => const OnboardingScreen(),
            Constants.agreementRoute: (_) => const AgreementScreen(),
            Constants.authWrapperRoute: (_) => const AuthWrapper(),
            Constants.welcomeRoute: (_) => const WelcomeScreen(),
            Constants.signInRoute: (_) => const SignInPage(),
            Constants.signUpRoute: (_) => const SignUpPage(),
            Constants.homeRoute: (_) => const MainScreen(),
            Constants.addTaskRoute: (context) {
              final args = ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
              return AddTaskScreen(prefilledTitle: args?['prefilledTitle']);
            },
            Constants.settingsRoute: (_) => const SettingsScreen(),
            Constants.aboutRoute: (_) => const AboutScreen(),
            Constants.statsRoute: (_) => const StatsScreen(),
            Constants.termsRoute: (_) => const TermsScreen(),
            Constants.privacyPolicyRoute: (_) => const PrivacyPolicyScreen(),
            Constants.changePasswordRoute: (_) => const ChangePasswordScreen(),
            Constants.accountRoute: (_) => const AccountScreen(),
            Constants.changeUsernameRoute: (_) => const ChangeUsernameScreen(),
            Constants.planningRoute: (_) => const PlanningScreen(),
            Constants.focusRoute: (_) => const FocusScreen(),
            Constants.addSubtaskRoute: (_) => const AddSubtaskScreen(),
            Constants.archivedTasksRoute: (_) => const ArchivedTasksScreen(),
            Constants.toolsRoute: (_) => const ToolsScreen(),
            Constants.manageCategoriesRoute: (_) => const ManageCategoriesScreen(),

            // **ADD THIS NEW ROUTE DEFINITION**
            Constants.categoryContentsRoute: (ctx) {
              final category = ctx.getRouteArgument<Category>();
              return category != null
                  ? CategoryContentsScreen(category: category)
                  : _buildErrorScreen("Category data is missing.");
            },

            Constants.taskDetailRoute: (ctx) {
              final taskId = ctx.getRouteArgument<String>();
              return taskId != null ? TaskDetailScreen(taskId: taskId) : _buildErrorScreen("Task ID is missing.");
            },
            Constants.noteDetailRoute: (ctx) {
              final noteId = ctx.getRouteArgument<String?>();
              return EditNoteScreen(noteId: noteId);
            },
          },
          debugShowCheckedModeBanner: false,
        );
      },
    );
  }

  Widget _buildErrorScreen(String message) {
    return Scaffold(appBar: AppBar(title: const Text("Routing Error")), body: Center(child: Padding(padding: const EdgeInsets.all(20.0), child: Column(mainAxisSize: MainAxisSize.min, children: [const Icon(Icons.error_outline, color: Colors.red, size: 50), const SizedBox(height: 16), Text(message, style: const TextStyle(fontSize: 16), textAlign: TextAlign.center), const SizedBox(height: 20), Builder(builder: (context) => ElevatedButton(onPressed: () => Navigator.maybePop(context), child: const Text("Go Back")))]))));
  }
}


// --- /lib/src/features/core/presentation/splash_screen.dart ---
// --- /lib/src/features/core/presentation/splash_screen.dart ---
class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen> with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );
    _fadeAnimation = CurvedAnimation(parent: _controller, curve: Curves.easeIn);
    _controller.forward();
    _initializeApp();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  Future<void> _initializeApp() async {
    // Increased delay to allow animation to feel natural
    await Future.delayed(const Duration(seconds: 3));

    if (mounted) {
      final prefs = await SharedPreferences.getInstance();
      final hasSeenOnboarding = prefs.getBool(Constants.hasSeenOnboardingKey) ?? false;
      final hasAgreedToTerms = prefs.getBool(Constants.hasAgreedToTermsKey) ?? false;

      if (!hasSeenOnboarding) {
        Navigator.pushReplacementNamed(context, Constants.onboardingRoute);
      } else if (!hasAgreedToTerms) {
        Navigator.pushReplacementNamed(context, Constants.agreementRoute);
      } else {
        Navigator.pushReplacementNamed(context, Constants.authWrapperRoute);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: FadeTransition(
          opacity: _fadeAnimation,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Spacer(),
              // A more modern and relevant icon
              Icon(Icons.task_alt_rounded, size: 80, color: Theme.of(context).colorScheme.primary),
              const SizedBox(height: 20),
              Text('NisanApp', style: Theme.of(context).textTheme.headlineMedium?.copyWith(fontWeight: FontWeight.w600)),
              const SizedBox(height: 8),
              Text('Your Smart Manager & Notebook', style: Theme.of(context).textTheme.titleSmall?.copyWith(color: Colors.grey.shade600)),
              const Spacer(),
              Padding(
                padding: const EdgeInsets.only(bottom: 40.0),
                child: Text(
                  'Powered by Featuremind Nigeria',
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Colors.grey),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// --- /lib/src/features/onboarding/presentation/onboarding_screen.dart ---
class OnboardingScreen extends StatefulWidget {
  const OnboardingScreen({super.key});

  @override
  State<OnboardingScreen> createState() => _OnboardingScreenState();
}

class _OnboardingScreenState extends State<OnboardingScreen> {
  final PageController _pageController = PageController();
  int _currentPage = 0;

  Future<void> _completeOnboarding() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(Constants.hasSeenOnboardingKey, true);
    if (mounted) {
      Navigator.pushReplacementNamed(context, Constants.agreementRoute);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: Column(
          children: [
            Expanded(
              child: PageView(
                controller: _pageController,
                onPageChanged: (index) {
                  setState(() {
                    _currentPage = index;
                  });
                },
                children: const [
                  OnboardingPage(
                    icon: Icons.checklist_rtl_rounded,
                    title: 'Welcome to NisanApp',
                    description: 'Your new smart manager and notebook. Organize your life, one task at a time.',
                  ),
                  OnboardingPage(
                    icon: Icons.auto_awesome,
                    title: 'Smart Task Creation',
                    description: 'Simply type "Meeting tomorrow at 2pm #work p:high" and let NisanApp handle the details.',
                  ),
                  OnboardingPage(
                    icon: Icons.av_timer_rounded,
                    title: 'Focus Hub',
                    description: 'Boost your productivity with the built-in Stopwatch and Countdown Timer.',
                  ),
                  OnboardingPage(
                    icon: Icons.cloud_sync_rounded,
                    title: 'Seamless Sync',
                    description: 'Your tasks and notes are securely synced across all your devices in real-time.',
                  ),
                ],
              ),
            ),
            Padding(
              padding: const EdgeInsets.all(24.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Row(
                    children: List.generate(4, (index) => _buildDot(index, context)),
                  ),
                  ElevatedButton(
                    onPressed: () {
                      if (_currentPage == 3) {
                        _completeOnboarding();
                      } else {
                        _pageController.nextPage(
                          duration: const Duration(milliseconds: 300),
                          curve: Curves.easeIn,
                        );
                      }
                    },
                    child: Text(_currentPage == 3 ? 'Get Started' : 'Next'),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDot(int index, BuildContext context) {
    return AnimatedContainer(
      duration: const Duration(milliseconds: 200),
      margin: const EdgeInsets.only(right: 5),
      height: 10,
      width: _currentPage == index ? 25 : 10,
      decoration: BoxDecoration(
        color: _currentPage == index ? Theme.of(context).colorScheme.primary : Colors.grey,
        borderRadius: BorderRadius.circular(5),
      ),
    );
  }
}

class OnboardingPage extends StatelessWidget {
  final IconData icon;
  final String title;
  final String description;

  const OnboardingPage({
    super.key,
    required this.icon,
    required this.title,
    required this.description,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(40.0),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 120, color: Theme.of(context).colorScheme.primary),
          const SizedBox(height: 40),
          Text(
            title,
            textAlign: TextAlign.center,
            style: Theme.of(context).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 16),
          Text(
            description,
            textAlign: TextAlign.center,
            style: Theme.of(context).textTheme.bodyLarge?.copyWith(color: Colors.grey.shade600),
          ),
        ],
      ),
    );
  }
}


// --- /lib/src/auth/auth_wrapper.dart ---
class AuthWrapper extends StatelessWidget {
  const AuthWrapper({super.key});

  @override
  Widget build(BuildContext context) {
    final authService = context.watch<AuthService>();
    return StreamBuilder<fb_auth.User?>(
      stream: authService.authStateChanges,
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Scaffold(body: Center(child: CircularProgressIndicator()));
        }
        if (snapshot.hasData) {
          return const MainScreen();
        }
        return const WelcomeScreen();
      },
    );
  }
}

// --- /lib/src/utils/context_extensions.dart ---
extension BuildContextExtensions on BuildContext { T? getRouteArgument<T>() { return ModalRoute.of(this)?.settings.arguments as T?; } }
String formatRelativeDate(DateTime date, {bool isNote = false}) { final now = DateTime.now(); final today = DateUtils.dateOnly(now); final dateOnly = DateUtils.dateOnly(date); final difference = dateOnly.difference(today).inDays; if (difference == 0) return 'Today'; if (difference == 1) return 'Tomorrow'; if (difference == -1) return 'Yesterday'; if (isNote) { if (now.difference(date).inDays < 7) { return DateFormat.EEEE().format(date); } else { return DateFormat.yMMMd().format(date); } } if (difference > 1 && difference <= 7) return 'In $difference days'; if (difference < -1 && difference >= -7) return '${difference.abs()} days ago'; return DateFormat.yMMMd().format(date); }

// --- /lib/src/features/auth/presentation/welcome_screen.dart ---
class WelcomeScreen extends StatefulWidget { const WelcomeScreen({super.key}); @override State<WelcomeScreen> createState() => _WelcomeScreenState(); }
class _WelcomeScreenState extends State<WelcomeScreen> with SingleTickerProviderStateMixin {
  late AnimationController _controller; late Animation<double> _fadeAnimation; late Animation<Offset> _slideAnimation;
  @override void initState() { super.initState(); _controller = AnimationController(duration: const Duration(milliseconds: 1000), vsync: this); _fadeAnimation = CurvedAnimation(parent: _controller, curve: Curves.easeIn); _slideAnimation = Tween<Offset>(begin: const Offset(0, 0.2), end: Offset.zero).animate(CurvedAnimation(parent: _controller, curve: Curves.easeOutCubic)); _controller.forward(); }
  @override void dispose() { _controller.dispose(); super.dispose(); }
  @override Widget build(BuildContext context) { return Scaffold(body: SafeArea(child: Center(child: SingleChildScrollView(child: Padding(padding: const EdgeInsets.symmetric(horizontal: 24.0, vertical: 40.0), child: FadeTransition(opacity: _fadeAnimation, child: Column(mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.stretch, children: <Widget>[SlideTransition(position: _slideAnimation, child: Icon(Icons.library_books_rounded, size: 80, color: Theme.of(context).colorScheme.primary)), const SizedBox(height: 24), _buildAnimatedText(Theme.of(context).textTheme.headlineMedium, 'Welcome to NisanApp!', 0), const SizedBox(height: 12), _buildAnimatedText(Theme.of(context).textTheme.titleMedium, 'Your Smart Manager & Notebook', 1), const SizedBox(height: 50), _buildAnimatedButton(child: ElevatedButton.icon(onPressed: () => Navigator.pushNamed(context, Constants.signInRoute), icon: const Icon(Icons.login), label: const Text('Sign In'), style: ElevatedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 14))), delayOrder: 2), const SizedBox(height: 16), _buildAnimatedButton(child: OutlinedButton.icon(onPressed: () => Navigator.pushNamed(context, Constants.signUpRoute), icon: const Icon(Icons.person_add_alt_1_outlined), label: const Text('Sign Up'), style: OutlinedButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.primary, side: BorderSide(color: Theme.of(context).colorScheme.primary), padding: const EdgeInsets.symmetric(vertical: 14))), delayOrder: 3)]))))))); }
  Widget _buildAnimatedText(TextStyle? style, String text, int delayOrder) { return TweenAnimationBuilder<double>(tween: Tween(begin: 0.0, end: 1.0), duration: Duration(milliseconds: 500 + delayOrder * 100), curve: Curves.easeOut, builder: (context, value, child) => Opacity(opacity: value, child: Padding(padding: EdgeInsets.only(top: 20 * (1 - value)), child: Text(text, style: style, textAlign: TextAlign.center)))); }
  Widget _buildAnimatedButton({required Widget child, required int delayOrder}) { return TweenAnimationBuilder<double>(tween: Tween(begin: 0.0, end: 1.0), duration: Duration(milliseconds: 500 + delayOrder * 150), curve: Curves.easeOutCubic, builder: (context, value, _) => Transform.translate(offset: Offset(0, 30 * (1 - value)), child: Opacity(opacity: value, child: child))); }
}

// --- /lib/src/features/auth/presentation/agreement_screen.dart ---
class AgreementScreen extends StatefulWidget {
  const AgreementScreen({super.key});

  @override
  State<AgreementScreen> createState() => _AgreementScreenState();
}

class _AgreementScreenState extends State<AgreementScreen> {
  bool _isAgreed = false;

  Future<void> _onContinue() async {
    if (_isAgreed) {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setBool(Constants.hasAgreedToTermsKey, true);
      if (mounted) {
        Navigator.pushReplacementNamed(context, Constants.authWrapperRoute);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              const Spacer(),
              Icon(
                Icons.gavel_rounded,
                size: 80,
                color: theme.colorScheme.primary,
              ),
              const SizedBox(height: 24),
              Text(
                'Before You Proceed',
                textAlign: TextAlign.center,
                style: theme.textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 16),
              RichText(
                textAlign: TextAlign.center,
                text: TextSpan(
                  style: theme.textTheme.bodyLarge?.copyWith(color: theme.colorScheme.onSurfaceVariant, height: 1.5),
                  children: [
                    const TextSpan(text: 'To ensure transparency and protect your rights, your use of NisanApp is subject to our legal terms. By proceeding, you confirm that you have read, understood, and unconditionally agree to be bound by our '),
                    TextSpan(
                      text: 'Terms of Service',
                      style: TextStyle(
                        color: theme.colorScheme.primary,
                        decoration: TextDecoration.underline,
                        fontWeight: FontWeight.bold,
                      ),
                      recognizer: TapGestureRecognizer()
                        ..onTap = () {
                          Navigator.pushNamed(context, Constants.termsRoute);
                        },
                    ),
                    const TextSpan(text: ' and '),
                    TextSpan(
                      text: 'Privacy Policy',
                      style: TextStyle(
                        color: theme.colorScheme.primary,
                        decoration: TextDecoration.underline,
                        fontWeight: FontWeight.bold,
                      ),
                      recognizer: TapGestureRecognizer()
                        ..onTap = () {
                          Navigator.pushNamed(context, Constants.privacyPolicyRoute);
                        },
                    ),
                    const TextSpan(text: '.'),
                  ],
                ),
              ),
              const Spacer(),
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Checkbox(
                    value: _isAgreed,
                    onChanged: (bool? value) {
                      setState(() {
                        _isAgreed = value ?? false;
                      });
                    },
                  ),
                  GestureDetector(
                    onTap: () {
                      setState(() {
                        _isAgreed = !_isAgreed;
                      });
                    },
                    child: const Text(
                      'I have read and agree to the terms.',
                      style: TextStyle(fontSize: 16),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: _isAgreed ? _onContinue : null,
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 14),
                ),
                child: const Text('Continue'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// --- /lib/src/common_widgets/task_form_field.dart ---
class TaskFormField extends StatelessWidget { final TextEditingController controller; final String labelText; final String? hintText; final String? Function(String?)? validator; final TextInputType? keyboardType; final bool obscureText; final Widget? prefixIcon; final void Function(String)? onChanged; final void Function(String)? onFieldSubmitted; final int maxLines; final TextCapitalization textCapitalization; final TextInputAction? textInputAction; final FocusNode? focusNode; final bool autofocus; final List<TextInputFormatter>? inputFormatters; const TaskFormField({super.key, required this.controller, required this.labelText, this.hintText, this.validator, this.keyboardType, this.obscureText = false, this.prefixIcon, this.onChanged, this.onFieldSubmitted, this.maxLines = 1, this.textCapitalization = TextCapitalization.none, this.textInputAction, this.focusNode, this.autofocus = false, this.inputFormatters}); @override Widget build(BuildContext context) { return TextFormField(focusNode: focusNode, controller: controller, autofocus: autofocus, inputFormatters: inputFormatters, decoration: InputDecoration(labelText: labelText, hintText: hintText, prefixIcon: prefixIcon, errorMaxLines: 3, suffixIcon: obscureText ? null : ValueListenableBuilder<TextEditingValue>(valueListenable: controller, builder: (context, value, child) => value.text.isNotEmpty ? IconButton(icon: const Icon(Icons.clear, size: 20), tooltip: "Clear", onPressed: () { controller.clear(); onChanged?.call(''); }) : const SizedBox.shrink())), validator: validator, keyboardType: keyboardType, obscureText: obscureText, onChanged: onChanged, onFieldSubmitted: onFieldSubmitted, maxLines: maxLines, textCapitalization: textCapitalization, textInputAction: textInputAction); } }
class PasswordFormField extends StatefulWidget { final TextEditingController controller; final String labelText; final String? Function(String?) validator; final TextInputAction? textInputAction; final void Function(String)? onFieldSubmitted; const PasswordFormField({super.key, required this.controller, required this.labelText, required this.validator, this.textInputAction, this.onFieldSubmitted}); @override State<PasswordFormField> createState() => _PasswordFormFieldState(); }
class _PasswordFormFieldState extends State<PasswordFormField> { bool _obscureText = true; @override Widget build(BuildContext context) { return TextFormField(controller: widget.controller, obscureText: _obscureText, validator: widget.validator, textInputAction: widget.textInputAction, onFieldSubmitted: widget.onFieldSubmitted, decoration: InputDecoration(labelText: widget.labelText, prefixIcon: const Icon(Icons.lock_outline), suffixIcon: IconButton(icon: AnimatedSwitcher(duration: const Duration(milliseconds: 200), transitionBuilder: (child, animation) => FadeTransition(opacity: animation, child: ScaleTransition(scale: animation, child: child)), child: Icon(_obscureText ? Icons.visibility_off_outlined : Icons.visibility_outlined, key: ValueKey<bool>(_obscureText))), onPressed: () => setState(() => _obscureText = !_obscureText)))); } }
class AnimatedCount extends StatelessWidget { final int count; final TextStyle? style; final Duration duration; const AnimatedCount({super.key, required this.count, this.style, this.duration = const Duration(milliseconds: 300)}); @override Widget build(BuildContext context) { return TweenAnimationBuilder<double>(tween: Tween(begin: count.toDouble(), end: count.toDouble()), duration: duration, builder: (context, value, child) => Text(value.toInt().toString(), style: style)); } }

// --- /lib/src/features/tasks/presentation/widgets/task_list_item.dart ---
class TaskListItem extends StatelessWidget {
  final Task task; final VoidCallback onTap; final VoidCallback onLongPress;
  final bool isArchivedView;
  const TaskListItem({super.key, required this.task, required this.onTap, required this.onLongPress, this.isArchivedView = false});
  Color _getPriorityColor(BuildContext context) { if (task.isComplete || isArchivedView) return Colors.transparent; switch (task.priority) { case Priority.high: return Theme.of(context).colorScheme.error; case Priority.medium: return Theme.of(context).colorScheme.tertiary; case Priority.low: return Colors.transparent; } }
  Widget _getStatusIcon(BuildContext context) { final colors = Theme.of(context).colorScheme; if (isArchivedView) { return Icon(Icons.archive_outlined, color: colors.outline, size: 24); } switch(task.status) { case TaskStatus.notStarted: return Icon(Icons.radio_button_unchecked, color: colors.outline, size: 24); case TaskStatus.inProgress: return Icon(Icons.data_usage_rounded, color: colors.primary, size: 24); case TaskStatus.completed: return Icon(Icons.check_circle_outline_rounded, color: Colors.green.shade600, size: 24); } }
  @override Widget build(BuildContext context) {
    final theme = Theme.of(context); final textTheme = theme.textTheme; final colorScheme = theme.colorScheme;
    final bool isReviewDue = task.isReviewDue;
    final bool isPastDue = !task.isComplete && task.dueDate != null && task.dueDate!.isBefore(DateUtils.dateOnly(DateTime.now()));
    final cardColor = isReviewDue ? colorScheme.tertiaryContainer.withOpacity(0.5) : theme.cardTheme.color;
    final completedTextColor = colorScheme.onSurface.withOpacity(0.6);
    final textStyle = textTheme.titleMedium?.copyWith(
        fontWeight: FontWeight.w600,
        decoration: (task.isComplete || isArchivedView) ? TextDecoration.lineThrough : null,
        decorationColor: completedTextColor,
        color: (task.isComplete || isArchivedView) ? completedTextColor : null);

    return Card(
        margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 5),
        color: cardColor,
        elevation: task.isComplete ? 0.5 : theme.cardTheme.elevation,
        shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12.0),
            side: isPastDue && !isArchivedView
                ? BorderSide(color: colorScheme.error.withOpacity(0.8), width: 1.5)
                : theme.cardTheme.shape is RoundedRectangleBorder
                ? (theme.cardTheme.shape as RoundedRectangleBorder).side
                : BorderSide(color: colorScheme.outline.withOpacity(0.2), width: 1.0)),
        child: InkWell(onTap: onTap, onLongPress: onLongPress, borderRadius: BorderRadius.circular(12.0),
            child: Row(children: [
              Container(width: 6, decoration: BoxDecoration(color: _getPriorityColor(context), borderRadius: const BorderRadius.only(topLeft: Radius.circular(12), bottomLeft: Radius.circular(12)))),
              Expanded(child: Padding(padding: const EdgeInsets.fromLTRB(10.0, 8.0, 4.0, 8.0),
                  child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
                    Row(crossAxisAlignment: CrossAxisAlignment.start, children: [
                      Padding(padding: const EdgeInsets.only(top: 4.0, right: 8.0), child: _getStatusIcon(context)),
                      Expanded(child: Text(task.title, maxLines: 2, overflow: TextOverflow.ellipsis, style: textStyle)),
                      if (task.isDailyPriority && !task.isComplete && !isArchivedView) Padding(padding: const EdgeInsets.symmetric(horizontal: 8.0), child: Icon(Icons.local_fire_department_rounded, color: Colors.orange.shade600, size: 20)),
                    ]),
                    if(task.subtasks.isNotEmpty) const SizedBox(height: 4),
                    if(task.subtasks.isNotEmpty) Padding(padding: const EdgeInsets.only(left: 32.0), child: LinearPercentIndicator(percent: task.progress, lineHeight: 6, barRadius: const Radius.circular(3), backgroundColor: colorScheme.surfaceVariant, progressColor: colorScheme.primary,)),
                    const SizedBox(height: 6),
                    Padding(padding: const EdgeInsets.only(left: 32.0), child: Wrap(spacing: 12.0, runSpacing: 4.0, crossAxisAlignment: WrapCrossAlignment.center, children: [
                      if (!task.isComplete && task.dueDate != null && !isArchivedView) _buildInfoChip(context, icon: Icons.calendar_today_outlined, text: formatRelativeDate(task.dueDate!), color: isPastDue ? colorScheme.error : colorScheme.onSurfaceVariant),
                      if (task.isComplete && task.nextSuggestedDate != null && !isArchivedView) _buildInfoChip(context, icon: isReviewDue ? Icons.replay_circle_filled_rounded : Icons.next_plan_outlined, text: '${isReviewDue ? "Review" : "Next"}: ${formatRelativeDate(task.nextSuggestedDate!)} (L${task.srsLevel})', color: isReviewDue ? colorScheme.primary : colorScheme.outline, isBold: isReviewDue),
                      if (task.hasDescription) _buildInfoChip(context, icon: Icons.subject_rounded, text: 'Notes', color: colorScheme.outline),
                      if (task.attachments.isNotEmpty) _buildInfoChip(context, icon: Icons.attach_file, text: '${task.attachments.length}', color: colorScheme.outline),
                      if (task.subtasks.isNotEmpty) _buildInfoChip(context, icon: Icons.account_tree_outlined, text: '${task.subtasks.where((s) => s.isCompleted).length}/${task.subtasks.length}', color: colorScheme.outline),
                      if (task.linkedNoteIds?.isNotEmpty ?? false) _buildInfoChip(context, icon: Icons.link_rounded, text: '${task.linkedNoteIds!.length}', color: colorScheme.outline),
                      ..._buildCategoryChips(context)
                    ]))
                  ])))
            ])));
  }
  Widget _buildInfoChip(BuildContext context, {required IconData icon, required String text, required Color color, bool isBold = false}) { return Row(mainAxisSize: MainAxisSize.min, children: [Icon(icon, size: 14, color: color), const SizedBox(width: 5), Text(text, style: Theme.of(context).textTheme.bodySmall?.copyWith(color: color, fontWeight: isBold ? FontWeight.bold : FontWeight.normal))]); }
  List<Widget> _buildCategoryChips(BuildContext context) { if (task.categories == null || task.categories!.isEmpty) return []; return task.categories!.take(2).map((cat) => Chip(label: Text(cat), materialTapTargetSize: MaterialTapTargetSize.shrinkWrap, visualDensity: const VisualDensity(horizontal: -4, vertical: -4), padding: const EdgeInsets.all(0), labelStyle: Theme.of(context).chipTheme.labelStyle, backgroundColor: Theme.of(context).chipTheme.backgroundColor, side: Theme.of(context).chipTheme.side)).toList(); }
}

// --- /lib/src/features/auth/presentation/signin_page.dart ---
class SignInPage extends StatefulWidget { const SignInPage({super.key}); @override State<SignInPage> createState() => _SignInPageState(); }
class _SignInPageState extends State<SignInPage> {
  final _fkey = GlobalKey<FormState>(); final _eCtrl = TextEditingController(); final _pCtrl = TextEditingController(); bool _loading = false;
  final AppLogger _logger = AppLogger();
  @override void dispose() { _eCtrl.dispose(); _pCtrl.dispose(); super.dispose(); }
  Future<void> _signIn() async {
    FocusScope.of(context).unfocus(); if (!_fkey.currentState!.validate()) return;
    setState(() => _loading = true);
    final authService = context.read<AuthService>();
    try {
      await authService.signInWithEmailAndPassword(email: _eCtrl.text.trim(), password: _pCtrl.text.trim());
      if (mounted) Navigator.pushNamedAndRemoveUntil(context, Constants.homeRoute, (r) => false);
    } on fb_auth.FirebaseAuthException catch (e) {
      if (mounted) {
        _logger.log("Sign in failed: ${e.code} - ${e.message}");
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(e.message ?? "An unknown error occurred."), backgroundColor: Theme.of(context).colorScheme.error));
      }
    } finally { if (mounted) setState(() => _loading = false); }
  }
  @override Widget build(BuildContext context) {
    return Scaffold(appBar: AppBar(title: const Text('Sign In')), body: Center(child: SingleChildScrollView(padding: const EdgeInsets.all(24), child: Form(key: _fkey, child: Column(mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.stretch, children: [
      Icon(Icons.lock_person_outlined, size: 60, color: Theme.of(context).colorScheme.primary), const SizedBox(height: 20), Text('Welcome Back!', style: Theme.of(context).textTheme.headlineSmall, textAlign: TextAlign.center), const SizedBox(height: 8), Text('Please sign in to your account.', style: Theme.of(context).textTheme.bodyMedium, textAlign: TextAlign.center), const SizedBox(height: 30),
      TaskFormField(controller: _eCtrl, labelText: 'Email', keyboardType: TextInputType.emailAddress, prefixIcon: const Icon(Icons.email_outlined), validator: (v) => (v == null || v.trim().isEmpty) ? 'Email is required.' : null, textInputAction: TextInputAction.next),
      const SizedBox(height: 20),
      PasswordFormField(controller: _pCtrl, labelText: 'Password', validator: (v) => (v == null || v.isEmpty) ? 'Password is required.' : null, textInputAction: TextInputAction.done, onFieldSubmitted: (_) => _signIn()),
      const SizedBox(height: 30),
      ElevatedButton(onPressed: _loading ? null : _signIn, child: _loading ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2)) : const Text('Sign In')),
      const SizedBox(height: 24),
      TextButton(onPressed: _loading ? null : () => Navigator.pushReplacementNamed(context, Constants.signUpRoute), child: const Text("Don't have an account? Sign Up"))
    ])))));
  }
}

// --- /lib/src/features/auth/presentation/signup_page.dart ---
class SignUpPage extends StatefulWidget { const SignUpPage({super.key}); @override State<SignUpPage> createState() => _SignUpPageState(); }
class _SignUpPageState extends State<SignUpPage> {
  final _fkey = GlobalKey<FormState>(); final _uCtrl = TextEditingController(); final _eCtrl = TextEditingController(); final _pCtrl = TextEditingController(); final _cpCtrl = TextEditingController(); bool _loading = false;
  final AppLogger _logger = AppLogger();
  @override void dispose() { _uCtrl.dispose(); _eCtrl.dispose(); _pCtrl.dispose(); _cpCtrl.dispose(); super.dispose(); }
  Future<void> _signUp() async {
    FocusScope.of(context).unfocus(); if (!_fkey.currentState!.validate()) return;
    setState(() => _loading = true);
    final authService = context.read<AuthService>();
    try {
      await authService.createUserWithEmailAndPassword(email: _eCtrl.text.trim(), password: _pCtrl.text.trim(), username: _uCtrl.text.trim());
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Account created! Please Sign In.'), backgroundColor: Colors.green));
        Navigator.pushNamedAndRemoveUntil(context, Constants.signInRoute, (r) => r.isFirst);
      }
    } on fb_auth.FirebaseAuthException catch (e) {
      if (mounted) {
        _logger.log("Sign up failed: ${e.code} - ${e.message}");
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(e.message ?? "An unknown error occurred."), backgroundColor: Theme.of(context).colorScheme.error));
      }
    } finally { if (mounted) setState(() => _loading = false); }
  }
  @override
  Widget build(BuildContext context) {
    return Scaffold(appBar: AppBar(title: const Text('Create Account')), body: Center(child: SingleChildScrollView(padding: const EdgeInsets.all(24), child: Form(key: _fkey, child: Column(mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.stretch, children: [
      Text('Account Details', style: Theme.of(context).textTheme.titleLarge, textAlign: TextAlign.center), const SizedBox(height: 30),
      TaskFormField(controller: _uCtrl, labelText: 'Username', prefixIcon: const Icon(Icons.person_outline), validator: (v) { if (v == null || v.trim().isEmpty) return 'Required'; if (v.trim().length < 3) return 'Must be at least 3 characters'; if (v.contains(' ')) return 'No spaces allowed'; return null; }, textInputAction: TextInputAction.next),
      const SizedBox(height: 20),
      TaskFormField(controller: _eCtrl, labelText: 'Email', prefixIcon: const Icon(Icons.email_outlined), keyboardType: TextInputType.emailAddress, validator: (v) { if (v == null || v.trim().isEmpty) return 'Required'; final r = RegExp(r"^\S+@\S+\.\S+$"); if (!r.hasMatch(v.trim())) return 'Invalid email format'; return null; }, textInputAction: TextInputAction.next),
      const SizedBox(height: 20),
      PasswordFormField(controller: _pCtrl, labelText: 'Password',validator: (v) { if (v == null || v.isEmpty) return 'Required'; if (v.length < 6) return 'Must be at least 6 characters'; return null; }, textInputAction: TextInputAction.next),
      const SizedBox(height: 20),
      PasswordFormField(controller: _cpCtrl, labelText: 'Confirm Password', validator: (v) { if (v == null || v.isEmpty) return 'Required'; if (v != _pCtrl.text) return 'Passwords must match'; return null; }, textInputAction: TextInputAction.done, onFieldSubmitted: (_) => _signUp()),
      const SizedBox(height: 25),
      RichText(textAlign: TextAlign.center, text: TextSpan(style: Theme.of(context).textTheme.bodySmall, children: [ const TextSpan(text: 'By signing up, you agree to our '), TextSpan(text: 'Terms', style: TextStyle(color: Theme.of(context).colorScheme.primary, decoration: TextDecoration.underline), recognizer: TapGestureRecognizer()..onTap = () { Navigator.pushNamed(context, Constants.termsRoute); }), const TextSpan(text: ' and '), TextSpan(text: 'Privacy Policy', style: TextStyle(color: Theme.of(context).colorScheme.primary, decoration: TextDecoration.underline), recognizer: TapGestureRecognizer()..onTap = () { Navigator.pushNamed(context, Constants.privacyPolicyRoute); }) ])),
      const SizedBox(height: 20),
      ElevatedButton(onPressed: _loading ? null : _signUp, child: _loading ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2)) : const Text('Create Account')),
      const SizedBox(height: 20),
      TextButton(onPressed: _loading ? null : () => Navigator.pushReplacementNamed(context, Constants.signInRoute), child: const Text('Already have an account? Sign In'))
    ])))));
  }
}

// --- /lib/src/features/core/presentation/main_screen.dart ---
class MainScreen extends StatefulWidget {
  const MainScreen({super.key});
  @override
  State<MainScreen> createState() => _MainScreenState();
}

class _MainScreenState extends State<MainScreen> with TickerProviderStateMixin {
  int _selectedIndex = 0;
  late final PageController _pageController;
  StreamSubscription? _intentStreamSubscription;
  final AppLogger _logger = AppLogger();

  @override
  void initState() {
    super.initState();
    _pageController = PageController(initialPage: _selectedIndex);
    _initReceiveIntent();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _checkAndShowWhatsNew(context);
      _checkAndShowPlanningPrompt(context);
    });
  }

  Future<void> _initReceiveIntent() async {
    _intentStreamSubscription = receive_intent.ReceiveIntent.receivedIntentStream.listen(
          (receive_intent.Intent? intent) {
        _handleSharedIntent(intent);
      },
      onError: (err) {
        _logger.log("ReceiveIntent Stream Error: $err");
      },
    );

    try {
      final receive_intent.Intent? initialIntent = await receive_intent.ReceiveIntent.getInitialIntent();
      _handleSharedIntent(initialIntent);
    } catch(e) {
      _logger.log("Error getting initial intent: $e");
    }
  }

  void _handleSharedIntent(receive_intent.Intent? intent) {
    if (intent == null ||
        intent.data == null ||
        intent.action != "android.intent.action.SEND") {
      return;
    }

    final String sharedText = intent.data!;

    if (sharedText.isNotEmpty && mounted) {
      _logger.log("Received shared text via Intent: $sharedText");
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          Navigator.pushNamed(context, Constants.addTaskRoute,
              arguments: {'prefilledTitle': sharedText});
        }
      });
    }
  }

  @override
  void dispose() {
    _pageController.dispose();
    _intentStreamSubscription?.cancel();
    super.dispose();
  }

  Future<void> _checkAndShowPlanningPrompt(BuildContext context) async {
    final prefs = await SharedPreferences.getInstance();
    final todayStr = DateFormat('yyyy-MM-dd').format(DateTime.now());
    final lastPlanningDate = prefs.getString(Constants.lastPlanningDateKey);

    if (lastPlanningDate != todayStr && context.mounted) {
      final snackBar = SnackBar(
        content: const Text('Ready to plan your day?'),
        action: SnackBarAction(
          label: 'PLAN',
          onPressed: () {
            Navigator.pushNamed(context, Constants.planningRoute);
          },
        ),
        duration: const Duration(seconds: 10),
      );
      ScaffoldMessenger.of(context).showSnackBar(snackBar);
    }
  }

  void _onItemTapped(int index) {
    if (_selectedIndex == index) return;
    HapticFeedback.lightImpact();
    setState(() => _selectedIndex = index);
    _pageController.animateToPage(index,
        duration: const Duration(milliseconds: 300), curve: Curves.easeInOut);
  }

  void _onQuickAdd() {
    showModalBottomSheet(
        context: context,
        isScrollControlled: true,
        builder: (ctx) => Padding(
          padding:
          EdgeInsets.only(bottom: MediaQuery.of(ctx).viewInsets.bottom),
          child: Container(
            padding: const EdgeInsets.all(16),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                ElevatedButton.icon(
                  icon: const Icon(Icons.checklist_rtl_rounded),
                  label: const Text("Add New Task"),
                  onPressed: () {
                    Navigator.pop(ctx);
                    Navigator.pushNamed(context, Constants.addTaskRoute);
                  },
                ),
                const SizedBox(height: 12),
                OutlinedButton.icon(
                  icon: const Icon(Icons.edit_note_outlined),
                  label: const Text("Add New Note"),
                  onPressed: () {
                    Navigator.pop(ctx);
                    Navigator.pushNamed(context, Constants.noteDetailRoute);
                  },
                ),
                const SizedBox(height: 16),
              ],
            ),
          ),
        ));
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: _buildDynamicAppBar(context),
      body: PageView(
        controller: _pageController,
        onPageChanged: (index) => setState(() => _selectedIndex = index),
        children: const [
          TasksView(),
          NotesView(),
          CalendarView(),
        ],
      ),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _selectedIndex,
        onTap: _onItemTapped,
        type: BottomNavigationBarType.fixed,
        selectedItemColor: Theme.of(context).colorScheme.primary,
        unselectedItemColor:
        Theme.of(context).colorScheme.onSurfaceVariant.withOpacity(0.8),
        items: const [
          BottomNavigationBarItem(
              icon: Icon(Icons.checklist_rtl_rounded),
              activeIcon: Icon(Icons.checklist_rtl_sharp),
              label: 'Tasks'),
          BottomNavigationBarItem(
              icon: Icon(Icons.edit_note_outlined),
              activeIcon: Icon(Icons.edit_note_sharp),
              label: 'Notes'),
          BottomNavigationBarItem(
              icon: Icon(Icons.calendar_month_outlined),
              activeIcon: Icon(Icons.calendar_month_sharp),
              label: 'Calendar'),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _onQuickAdd,
        tooltip: 'Add Item',
        child: const Icon(Icons.add),
      ),
    );
  }

  AppBar _buildDynamicAppBar(BuildContext context) {
    switch (_selectedIndex) {
      case 0: // Tasks
        return AppBar(
          title: Consumer<TaskManager>(
              builder: (context, taskManager, _) => AnimatedSwitcher(
                  duration: const Duration(milliseconds: 300),
                  transitionBuilder: (Widget child, Animation<double> animation) =>
                      FadeTransition(opacity: animation, child: child),
                  child: Text(_getTaskAppBarTitle(taskManager),
                      key: ValueKey<String>(_getTaskAppBarTitle(taskManager)),
                      overflow: TextOverflow.ellipsis))),
          centerTitle: true,
          titleSpacing: 0,
          leading: _buildReviewDueButton(context, context.watch<TaskManager>()),
          actions: [
            _buildToolsButton(context), // NEW
            _buildSearchButton(context),
            _buildMainMenu(context, context.watch<TaskManager>())
          ],
        );
      case 1: // Notes
        return AppBar(
          title: Consumer<NoteManager>(
              builder: (context, noteManager, _) =>
                  Text("Notes (${noteManager.notes.length})")),
          centerTitle: true,
          actions: [
            _buildToolsButton(context), // NEW
            _buildSearchButton(context),
            _buildNoteMenu(context, context.watch<NoteManager>())
          ],
        );
      case 2: // Calendar
        return AppBar(
          title: const Text("Calendar"),
          centerTitle: true,
          actions: [_buildToolsButton(context), _buildSearchButton(context)], // NEW
        );
      default:
        return AppBar();
    }
  }

  // NEW: Button to open the Tools screen
  Widget _buildToolsButton(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.calculate_outlined),
      tooltip: "Quick Tools",
      onPressed: () {
        Navigator.pushNamed(context, Constants.toolsRoute);
      },
    );
  }

  Widget _buildSearchButton(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.search),
      tooltip: "Search",
      onPressed: () => showSearch(
          context: context,
          delegate: UnifiedSearchDelegate(
            context.read<TaskManager>(),
            context.read<NoteManager>(),
            context.read<SharedPreferences>(),
          )),
    );
  }

  String _getTaskAppBarTitle(TaskManager taskManager) {
    if (taskManager.activeSmartFilter != SmartFilter.none) {
      switch (taskManager.activeSmartFilter) {
        case SmartFilter.overdue:
          return "Overdue (${taskManager.tasks.length})";
        case SmartFilter.dueToday:
          return "Due Today (${taskManager.tasks.length})";
        case SmartFilter.highPriority:
          return "High Priority (${taskManager.tasks.length})";
        case SmartFilter.dailyPriority:
          return "Today's Priorities (${taskManager.tasks.length})";
        default:
          break;
      }
    }
    if (taskManager.reviewDueFilterActive)
      return "Reviews Due (${taskManager.tasks.length})";
    if (taskManager.filterCategory != "All")
      return "${taskManager.filterCategory} (${taskManager.tasks.length})";
    return "All Tasks (${taskManager.tasks.length})";
  }

  Widget _buildReviewDueButton(BuildContext context, TaskManager taskManager) {
    return Tooltip(
      message: "Reviews (${taskManager.reviewDueCount})",
      child: TextButton.icon(
        style: TextButton.styleFrom(
            foregroundColor: taskManager.reviewDueFilterActive
                ? Theme.of(context).colorScheme.primary
                : Theme.of(context).colorScheme.onSurfaceVariant.withOpacity(0.8)),
        icon: Badge(
          label: Text('${taskManager.reviewDueCount}',
              style: const TextStyle(
                  color: Colors.black,
                  fontSize: 10,
                  fontWeight: FontWeight.bold)),
          backgroundColor: Theme.of(context).colorScheme.primary,
          isLabelVisible:
          taskManager.reviewDueCount > 0 && !taskManager.reviewDueFilterActive,
          child: Icon(taskManager.reviewDueFilterActive
              ? Icons.rule_folder_sharp
              : Icons.rule_folder_outlined),
        ),
        label: const Text("Due"),
        onPressed: (taskManager.reviewDueCount > 0 ||
            taskManager.reviewDueFilterActive)
            ? () => taskManager.reviewDueFilterActive =
        !taskManager.reviewDueFilterActive
            : null,
      ),
    );
  }

  Widget _buildMainMenu(BuildContext context, TaskManager taskManager) {
    final hasCompletedTasks = taskManager.completedTaskCount > 0;
    return PopupMenuButton<dynamic>(
        tooltip: "More Options",
        icon: const Icon(Icons.more_vert),
        itemBuilder: (context) => [
          const PopupMenuItem(
              value: 'plan_day',
              child: ListTile(
                  leading: Icon(Icons.edit_calendar_outlined),
                  title: Text("Plan Your Day"))),
          const PopupMenuDivider(),
          PopupMenuItem(
              value: 'filter',
              child: PopupMenuButton<String>(
                  tooltip: "Filter by Category",
                  onSelected: (cat) => taskManager.filterCategory = cat,
                  itemBuilder: (_) => taskManager.allCategories
                      .map((cat) => PopupMenuItem(
                      value: cat,
                      child: Text(cat,
                          style: TextStyle(
                              fontWeight:
                              taskManager.filterCategory == cat
                                  ? FontWeight.bold
                                  : FontWeight.normal))))
                      .toList(),
                  child: const ListTile(
                      leading: Icon(Icons.filter_list),
                      title: Text("Filter by Category")))),
          PopupMenuItem(
              value: 'sort',
              child: PopupMenuButton<SortOption>(
                  tooltip: "Sort Tasks",
                  onSelected: (opt) => taskManager.sortOption = opt,
                  itemBuilder: (_) {
                    const names = {
                      SortOption.dueDate: "Due Date",
                      SortOption.priority: "Priority",
                      SortOption.creationDate: "Newest",
                      SortOption.nextSuggestedDate: "Review Date",
                      SortOption.title: "Title"
                    };
                    return SortOption.values
                        .map((opt) => PopupMenuItem(
                        value: opt,
                        child: Text(names[opt]!,
                            style: TextStyle(
                                fontWeight:
                                taskManager.sortOption == opt
                                    ? FontWeight.bold
                                    : FontWeight.normal))))
                        .toList();
                  },
                  child: const ListTile(
                      leading: Icon(Icons.sort), title: Text("Sort By")))),
          const PopupMenuDivider(),
          CheckedPopupMenuItem(
              value: 'toggle_completed',
              checked: taskManager.showCompleted,
              child: Text(taskManager.showCompleted
                  ? "Hide Completed"
                  : "Show Completed")),
          if (hasCompletedTasks) const PopupMenuDivider(),
          if (hasCompletedTasks)
            PopupMenuItem(
                value: 'archive_completed',
                child: ListTile(
                    leading: Icon(Icons.archive_outlined,
                        color: Theme.of(context).colorScheme.secondary),
                    title: Text('Archive All Completed',
                        style: TextStyle(
                            color: Theme.of(context).colorScheme.secondary)))),
          const PopupMenuItem(
              value: 'view_archive',
              child: ListTile(
                  leading: Icon(Icons.inventory_2_outlined),
                  title: Text("View Archived Tasks"))),
          const PopupMenuDivider(),
          const PopupMenuItem(
              value: 'settings',
              child: ListTile(
                  leading: Icon(Icons.settings_outlined),
                  title: Text("Settings"))),
        ],
        onSelected: (value) async {
          if (value == 'toggle_completed') {
            HapticFeedback.lightImpact();
            taskManager.showCompleted = !taskManager.showCompleted;
          } else if (value == 'settings') {
            Navigator.pushNamed(context, Constants.settingsRoute);
          } else if (value == 'archive_completed') {
            _confirmArchiveCompleted(context, taskManager);
          } else if (value == 'plan_day') {
            Navigator.pushNamed(context, Constants.planningRoute);
          } else if (value == 'view_archive') {
            Navigator.pushNamed(context, Constants.archivedTasksRoute);
          }
        });
  }

  Widget _buildNoteMenu(BuildContext context, NoteManager noteManager) {
    return PopupMenuButton<NoteSortOption>(
        tooltip: "Sort Notes",
        icon: const Icon(Icons.sort),
        onSelected: (opt) => noteManager.sortOption = opt,
        itemBuilder: (_) {
          const names = {
            NoteSortOption.lastModified: "Last Modified",
            NoteSortOption.creationDate: "Creation Date",
            NoteSortOption.title: "Title"
          };
          return NoteSortOption.values
              .map((opt) => PopupMenuItem(
              value: opt,
              child: Text(names[opt]!,
                  style: TextStyle(
                      fontWeight: noteManager.sortOption == opt
                          ? FontWeight.bold
                          : FontWeight.normal))))
              .toList();
        });
  }

  Future<void> _confirmArchiveCompleted(
      BuildContext context, TaskManager taskManager) async {
    final confirm = await showDialog<bool>(
        context: context,
        builder: (ctx) => AlertDialog(
            title: const Text('Confirm Archive'),
            content: Text(
                'Are you sure you want to archive all ${taskManager.completedTaskCount} completed tasks? They will be hidden from the main list but can be viewed later.'),
            actions: [
              TextButton(
                  onPressed: () => Navigator.of(ctx).pop(false),
                  child: const Text('Cancel')),
              TextButton(
                  onPressed: () => Navigator.of(ctx).pop(true),
                  style: TextButton.styleFrom(
                      foregroundColor:
                      Theme.of(context).colorScheme.secondary),
                  child: const Text('Archive All'))
            ]));
    if (confirm == true && mounted) {
      await taskManager.archiveAllCompletedTasks();
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
          content: Text('Completed tasks archived!'),
          backgroundColor: Colors.green));
    }
  }

  Future<void> _checkAndShowWhatsNew(BuildContext context) async {
    final prefs = await SharedPreferences.getInstance();
    final packageInfo = await PackageInfo.fromPlatform();
    final lastSeenVersion = prefs.getString(Constants.lastSeenVersionKey);
    final currentVersion = packageInfo.version;

    if (lastSeenVersion != currentVersion) {
      if (mounted) {
        showDialog(
          context: context,
          builder: (ctx) => AlertDialog(
            title: const Text("What's New in NisanApp"),
            content: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _buildFeatureRow(Icons.calculate_outlined, 'Quick Tools & Calculator',
                      'Access an in-app calculator from the main screen for quick calculations, perfect for budgeting or expense tracking.'),
                  _buildFeatureRow(Icons.label_important_outline, 'Custom Categories',
                      'Create, edit, and manage your own task categories in the settings for a fully personalized workflow.'),
                  _buildFeatureRow(Icons.archive_outlined, 'Task Archiving',
                      'Instead of deleting, you can now archive completed tasks to keep your list clean while preserving stats.'),
                  _buildFeatureRow(Icons.link, 'Focus Session Linking',
                      'Link a countdown timer directly to a task to automatically track your focus time.'),
                ],
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(ctx).pop(),
                child: const Text("Awesome!"),
              ),
            ],
          ),
        );
        await prefs.setString(Constants.lastSeenVersionKey, currentVersion);
      }
    }
  }

  Widget _buildFeatureRow(IconData icon, String title, String subtitle) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(icon, color: Theme.of(context).colorScheme.primary, size: 28),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(title,
                    style: Theme.of(context)
                        .textTheme
                        .titleMedium
                        ?.copyWith(fontWeight: FontWeight.bold)),
                const SizedBox(height: 2),
                Text(subtitle, style: Theme.of(context).textTheme.bodyMedium),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

// --- ENHANCEMENT: WIDGET FOR ANIMATED LIST ITEMS ---
class AnimatedListItem extends StatefulWidget {
  final Widget child;
  final int index;

  const AnimatedListItem({super.key, required this.child, required this.index});

  @override
  State<AnimatedListItem> createState() => _AnimatedListItemState();
}

class _AnimatedListItemState extends State<AnimatedListItem> with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 400),
      vsync: this,
    );
    final delay = (widget.index * 50).clamp(0, 400);
    Future.delayed(Duration(milliseconds: delay), () {
      if(mounted) {
        _controller.forward();
      }
    });

    _animation = CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOutCubic,
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return FadeTransition(
      opacity: _animation,
      child: SlideTransition(
        position: Tween<Offset>(
          begin: const Offset(0.0, 0.2),
          end: Offset.zero,
        ).animate(_animation),
        child: widget.child,
      ),
    );
  }
}


// --- /lib/src/features/tasks/presentation/tasks_view.dart ---
class TasksView extends StatefulWidget {
  const TasksView({super.key});

  @override
  State<TasksView> createState() => _TasksViewState();
}

class _TasksViewState extends State<TasksView> {
  final ScrollController _scrollController = ScrollController();
  bool _showScrollButton = false;
  bool _hasPlannedToday = false;

  @override
  void initState() {
    super.initState();
    _checkPlanningStatus();
    _scrollController.addListener(() {
      if (_scrollController.offset > 300 && !_showScrollButton) {
        setState(() => _showScrollButton = true);
      } else if (_scrollController.offset <= 300 && _showScrollButton) {
        setState(() => _showScrollButton = false);
      }
    });
  }

  Future<void> _checkPlanningStatus() async {
    final prefs = await SharedPreferences.getInstance();
    final todayStr = DateFormat('yyyy-MM-dd').format(DateTime.now());
    final lastPlanningDate = prefs.getString(Constants.lastPlanningDateKey);
    if(mounted) {
      setState(() {
        _hasPlannedToday = (lastPlanningDate == todayStr);
      });
    }
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  String _getGreeting() { final hour = DateTime.now().hour; if (hour < 12) return 'Good Morning'; if (hour < 17) return 'Good Afternoon'; return 'Good Evening'; }

  @override
  Widget build(BuildContext context) {
    final taskManager = context.watch<TaskManager>();
    _checkPlanningStatus();

    return Stack(
      children: [
        Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 8, 16, 8),
            child: StreamBuilder<fb_auth.User?>(
                stream: fb_auth.FirebaseAuth.instance.userChanges(),
                builder: (context, snapshot) {
                  final username = snapshot.data?.displayName ?? 'User';
                  return Text('${_getGreeting()}, $username!', style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600));
                }
            ),
          ),
          _buildDashboard(context, taskManager),
          const Padding(padding: EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0), child: Divider(height: 1)),
          Expanded(child: _buildTaskList(context, taskManager))
        ]),
        Positioned(
          bottom: 16, right: 16,
          child: AnimatedOpacity(
            opacity: _showScrollButton ? 1.0 : 0.0,
            duration: const Duration(milliseconds: 300),
            child: FloatingActionButton.small(
              onPressed: () => _scrollController.animateTo(0, duration: const Duration(milliseconds: 500), curve: Curves.easeInOut),
              tooltip: 'Scroll to top',
              child: const Icon(Icons.arrow_upward),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildDashboard(BuildContext context, TaskManager taskManager) {
    return SingleChildScrollView( scrollDirection: Axis.horizontal, padding: const EdgeInsets.symmetric(horizontal: 12),
      child: Row(children: [
        if (taskManager.currentStreak > 0)
          _buildDashboardCard(
            context,
            taskManager,
            icon: Icons.whatshot_rounded,
            label: '${taskManager.currentStreak}-Day Streak',
            count: taskManager.currentStreak,
            color: Colors.deepOrange.shade600,
            filter: SmartFilter.none,
            onTapOverride: () {},
          ),
        if (!_hasPlannedToday || taskManager.dailyPriorityCount > 0)
          _buildDashboardCard(
            context,
            taskManager,
            icon: _hasPlannedToday ? Icons.local_fire_department_rounded : Icons.edit_calendar_outlined,
            label: _hasPlannedToday ? "Today's Focus" : "Plan Your Day",
            count: taskManager.dailyPriorityCount,
            color: _hasPlannedToday ? Colors.orange.shade600 : Theme.of(context).colorScheme.secondary,
            filter: SmartFilter.dailyPriority,
            onTapOverride: _hasPlannedToday
                ? null
                : () {
              Navigator.pushNamed(context, Constants.planningRoute).then((_) {
                _checkPlanningStatus();
              });
            },
          ),
        _buildDashboardCard(context, taskManager, icon: Icons.error_outline_rounded, label: 'Overdue', count: taskManager.overdueCount, color: Colors.orange.shade800, filter: SmartFilter.overdue),
        _buildDashboardCard(context, taskManager, icon: Icons.today_rounded, label: 'Due Today', count: taskManager.dueTodayCount, color: Colors.blue.shade600, filter: SmartFilter.dueToday),
        _buildDashboardCard(context, taskManager, icon: Icons.priority_high_rounded, label: 'High Prio', count: taskManager.highPriorityCount, color: Colors.redAccent.shade400, filter: SmartFilter.highPriority)
      ]),
    );
  }

  Widget _buildDashboardCard(BuildContext context, TaskManager taskManager, {required IconData icon, required String label, required int count, required Color color, required SmartFilter filter, VoidCallback? onTapOverride}) {
    final theme = Theme.of(context); final isActive = taskManager.activeSmartFilter == filter;
    final cardColor = isActive ? color.withOpacity(0.2) : theme.colorScheme.surfaceVariant.withOpacity(0.5);
    final onCardColor = isActive ? color : theme.colorScheme.onSurfaceVariant;
    return GestureDetector(
      onTap: onTapOverride ?? () { if (count > 0 || isActive) { HapticFeedback.lightImpact(); taskManager.applySmartFilter(filter); } },
      child: Card(
          elevation: isActive ? 2 : 0.5, color: cardColor,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12), side: isActive ? BorderSide(color: color, width: 1.5) : BorderSide(color: theme.colorScheme.outline.withOpacity(0.2))),
          child: Padding(padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
                Row(children: [Icon(icon, color: onCardColor, size: 20), const SizedBox(width: 8), Text(label, style: theme.textTheme.labelLarge?.copyWith(color: onCardColor, fontWeight: FontWeight.bold))]),
                const SizedBox(height: 6),
                if(label.contains("Streak")) Text("Keep it up!", style: theme.textTheme.headlineSmall?.copyWith(color: onCardColor, fontWeight: FontWeight.bold))
                else AnimatedCount(count: count, style: theme.textTheme.headlineSmall?.copyWith(color: onCardColor, fontWeight: FontWeight.bold))
              ]))),
    );
  }

  Widget _buildEmptyState(BuildContext context, TaskManager taskManager) {
    String emptyMessage = 'No tasks found';
    String emptySubMessage = 'Try changing your filters or add a new task.';
    bool isDefaultView = taskManager.activeSmartFilter == SmartFilter.none &&
        taskManager.searchQuery.isEmpty &&
        taskManager.filterCategory == 'All';

    if (isDefaultView) {
      emptyMessage = 'All clear!';
      emptySubMessage = 'Tap the button below to create your first task and get started.';
    } else if (taskManager.searchQuery.isNotEmpty) {
      emptyMessage = 'No tasks match your search.';
      emptySubMessage = 'Try a different search term.';
    } else {
      emptyMessage = 'You are all caught up!';
      emptySubMessage = 'No tasks match the current filters.';
    }

    final Widget textContent = Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        Text(emptyMessage,
            textAlign: TextAlign.center,
            style: Theme.of(context)
                .textTheme
                .headlineSmall
                ?.copyWith(color: Colors.grey.shade600)),
        const SizedBox(height: 8),
        Text(emptySubMessage,
            style: const TextStyle(color: Colors.grey),
            textAlign: TextAlign.center),
        if (isDefaultView) ...[
          const SizedBox(height: 24),
          ElevatedButton.icon(
              icon: const Icon(Icons.add),
              label: const Text("Add Your First Task"),
              onPressed: () =>
                  Navigator.pushNamed(context, Constants.addTaskRoute))
        ]
      ],
    );

    final Widget iconContent = Icon(Icons.library_add_check_outlined,
        size: 70, color: Colors.grey[400]);

    return SingleChildScrollView(
      physics: const BouncingScrollPhysics(parent: AlwaysScrollableScrollPhysics()),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 30.0, vertical: 50.0),
        child: Center(
          child: OrientationBuilder(
            builder: (context, orientation) {
              if (orientation == Orientation.portrait) {
                return Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    iconContent,
                    const SizedBox(height: 20),
                    textContent,
                  ],
                );
              } else {
                return Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    iconContent,
                    const SizedBox(width: 30),
                    Flexible(child: textContent),
                  ],
                );
              }
            },
          ),
        ),
      ),
    );
  }

  void _showContextMenu(BuildContext context, Task task) {
    HapticFeedback.lightImpact();
    showModalBottomSheet( context: context, builder: (ctx) => Wrap(children: <Widget>[
      ListTile( leading: const Icon(Icons.copy_all_rounded), title: const Text('Copy Task Title'),
          onTap: () { Clipboard.setData(ClipboardData(text: task.title)); Navigator.of(ctx).pop(); ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Task title copied to clipboard!'), duration: Duration(seconds: 2))); }),
      ListTile( leading: const Icon(Icons.share_rounded), title: const Text('Share Task'),
          onTap: () {
            final StringBuffer shareText = StringBuffer(); shareText.writeln('📋 Task: ${task.title}');
            if (task.dueDate != null) { shareText.writeln('🗓️ Due: ${DateFormat.yMd().add_jm().format(task.dueDate!)}'); }
            if (task.hasDescription) { shareText.writeln('\n${task.description}'); }
            Share.share(shareText.toString(), subject: 'NisanApp Task: ${task.title}'); Navigator.of(ctx).pop();
          }),
      const Divider(height: 1),
      ListTile( leading: Icon(Icons.cancel_outlined, color: Theme.of(context).colorScheme.outline), title: Text('Cancel', style: TextStyle(color: Theme.of(context).colorScheme.outline)), onTap: () => Navigator.of(ctx).pop())
    ]));
  }

  Widget _buildTaskList(BuildContext context, TaskManager taskManager) {
    if (taskManager.isLoading) return const Center(child: CircularProgressIndicator());
    final tasks = taskManager.tasks;
    if (tasks.isEmpty) return _buildEmptyState(context, taskManager);
    return ListView.builder(
      controller: _scrollController,
      padding: const EdgeInsets.fromLTRB(4, 4, 4, 88),
      itemCount: tasks.length,
      itemBuilder: (context, index) {
        final task = tasks[index];
        return AnimatedListItem(
          index: index,
          child: Slidable(
            key: ValueKey(task.id),
            startActionPane: ActionPane(
              motion: const StretchMotion(),
              children: [
                SlidableAction(
                  onPressed: (ctx) => taskManager.updateTaskStatus(task.id, TaskStatus.completed),
                  backgroundColor: Colors.green, foregroundColor: Colors.white,
                  icon: Icons.check, label: 'Done',
                ),
              ],
            ),
            endActionPane: ActionPane(
              motion: const StretchMotion(),
              children: [
                SlidableAction(
                  onPressed: (ctx) => _confirmArchive(context, task, taskManager),
                  backgroundColor: Theme.of(context).colorScheme.secondary, foregroundColor: Colors.white,
                  icon: Icons.archive_outlined, label: 'Archive',
                ),
              ],
            ),
            child: TaskListItem(
                task: task,
                onTap: () => Navigator.pushNamed(context, Constants.taskDetailRoute, arguments: task.id),
                onLongPress: () => _showContextMenu(context, task)),
          ),
        );
      },
    );
  }

  Future<void> _confirmArchive(BuildContext context, Task task, TaskManager taskManager) async {
    final bool? confirmed = await showDialog<bool>(context: context, builder: (ctx) => AlertDialog(title: const Text('Confirm Archive'), content: Text('Are you sure you want to archive "${task.title}"?'), actions: [TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('Cancel')), TextButton(onPressed: () => Navigator.of(ctx).pop(true), style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.secondary), child: const Text('Archive'))]));
    if (confirmed == true && mounted) {
      await taskManager.archiveTask(task.id);
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(
            content: Text("Task '${task.title}' archived."),
            duration: const Duration(seconds: 4),
            action: SnackBarAction(label: "UNDO", onPressed: () => taskManager.undoArchiveTask())
        ));
      }
    }
  }
}

// --- /lib/src/features/search/unified_search_delegate.dart ---
class UnifiedSearchDelegate extends SearchDelegate<dynamic> {
  final TaskManager taskManager;
  final NoteManager noteManager;
  final SharedPreferences prefs;
  List<String> _recentSearches = [];

  UnifiedSearchDelegate(this.taskManager, this.noteManager, this.prefs) {
    _loadRecentSearches();
  }

  void _loadRecentSearches() {
    _recentSearches = prefs.getStringList(Constants.recentSearchesKey) ?? [];
  }

  Future<void> _saveRecentSearch(String term) async {
    if (term.isEmpty) return;
    _recentSearches.remove(term);
    _recentSearches.insert(0, term);
    if (_recentSearches.length > 5) {
      _recentSearches = _recentSearches.sublist(0, 5);
    }
    await prefs.setStringList(Constants.recentSearchesKey, _recentSearches);
  }

  @override ThemeData appBarTheme(BuildContext context) { final theme = Theme.of(context); return theme.copyWith(appBarTheme: theme.appBarTheme.copyWith(backgroundColor: theme.colorScheme.surface), inputDecorationTheme: const InputDecorationTheme(border: InputBorder.none)); }
  @override List<Widget>? buildActions(BuildContext context) => [if (query.isNotEmpty) IconButton(icon: const Icon(Icons.clear), onPressed: () => query = '')];
  @override Widget? buildLeading(BuildContext context) => IconButton(icon: const Icon(Icons.arrow_back), onPressed: () => close(context, null));

  @override Widget buildResults(BuildContext context) {
    _saveRecentSearch(query);
    return _build(context);
  }
  @override Widget buildSuggestions(BuildContext context) {
    if (query.isEmpty && _recentSearches.isNotEmpty) {
      return _buildRecentSearches(context);
    }
    return _build(context);
  }

  Widget _buildRecentSearches(BuildContext context) {
    return ListView.builder(
      itemCount: _recentSearches.length,
      itemBuilder: (context, index) {
        final term = _recentSearches[index];
        return ListTile(
          leading: const Icon(Icons.history),
          title: Text(term),
          onTap: () {
            query = term;
            showResults(context);
          },
          trailing: IconButton(
            icon: const Icon(Icons.clear),
            onPressed: () async {
              _recentSearches.removeAt(index);
              await prefs.setStringList(Constants.recentSearchesKey, _recentSearches);
              query = '';
            },
          ),
        );
      },
    );
  }

  Widget _build(BuildContext context) {
    if (query.isEmpty) return const Center(child: Text("Search tasks and notes..."));

    String mainQuery = query;
    Priority? priorityFilter;
    DateTime? dueDateFilter;
    String? tagFilter;

    final pRegex = RegExp(r"p(?:riority)?:(high|medium|low)\b", caseSensitive: false);
    final dueRegex = RegExp(r"due:(today|tomorrow|overdue)\b", caseSensitive: false);
    final tagRegex = RegExp(r"tag:(\w+)\b", caseSensitive: false);

    mainQuery = mainQuery.replaceAllMapped(pRegex, (m) {
      switch(m.group(1)?.toLowerCase()){
        case 'high': priorityFilter = Priority.high; break;
        case 'medium': priorityFilter = Priority.medium; break;
        case 'low': priorityFilter = Priority.low; break;
      }
      return '';
    }).trim();

    mainQuery = mainQuery.replaceAllMapped(dueRegex, (m) {
      final now = DateTime.now();
      switch(m.group(1)?.toLowerCase()){
        case 'today': dueDateFilter = DateUtils.dateOnly(now); break;
        case 'tomorrow': dueDateFilter = DateUtils.dateOnly(now.add(const Duration(days: 1))); break;
        case 'overdue': dueDateFilter = DateTime(0); break;
      }
      return '';
    }).trim();

    mainQuery = mainQuery.replaceAllMapped(tagRegex, (m) {
      tagFilter = m.group(1);
      return '';
    }).trim();

    List<Task> filteredTasks = taskManager.originalTasks;
    if (priorityFilter != null) {
      filteredTasks = filteredTasks.where((t) => t.priority == priorityFilter).toList();
    }
    if (dueDateFilter != null) {
      if (dueDateFilter == DateTime(0)) {
        filteredTasks = filteredTasks.where((t) => !t.isComplete && t.dueDate != null && t.dueDate!.isBefore(DateUtils.dateOnly(DateTime.now()))).toList();
      } else {
        filteredTasks = filteredTasks.where((t) => t.dueDate != null && DateUtils.isSameDay(t.dueDate, dueDateFilter)).toList();
      }
    }
    if (tagFilter != null) {
      filteredTasks = filteredTasks.where((t) => t.categories?.any((c) => c.toLowerCase() == tagFilter?.toLowerCase()) ?? false).toList();
    }
    if (mainQuery.isNotEmpty) {
      final q = mainQuery.toLowerCase();
      filteredTasks = filteredTasks.where((t) => t.title.toLowerCase().contains(q) || (t.description?.toLowerCase().contains(q) ?? false)).toList();
    }

    List<Note> filteredNotes = noteManager.originalNotes.where((n) {
      final q = mainQuery.toLowerCase();
      return n.title.toLowerCase().contains(q) || n.content.toLowerCase().contains(q);
    }).toList();

    if (filteredTasks.isEmpty && filteredNotes.isEmpty) return Center(child: Text("No results found for '$query'"));

    return ListView(children: [
      if(filteredTasks.isNotEmpty) ...[
        _buildSectionHeader(context, "Tasks"),
        ...filteredTasks.map((task) => TaskListItem(task: task, onTap: () { close(context, null); Navigator.pushNamed(context, Constants.taskDetailRoute, arguments: task.id); }, onLongPress: (){})).toList(),
      ],
      if(filteredNotes.isNotEmpty) ...[
        _buildSectionHeader(context, "Notes"),
        ...filteredNotes.map((note) => NoteListItem(note: note, onTap: () { close(context, null); Navigator.pushNamed(context, Constants.noteDetailRoute, arguments: note.id); })).toList(),
      ]
    ]);
  }

  Padding _buildSectionHeader(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
      child: Text(title.toUpperCase(), style: Theme.of(context).textTheme.labelSmall?.copyWith(color: Theme.of(context).colorScheme.primary, fontWeight: FontWeight.bold)),
    );
  }
}

// --- /lib/src/features/tasks/utils/task_parser.dart ---
class ParsedTaskData {
  String title;
  DateTime? dueDate;
  Priority? priority;
  List<String> categories;

  ParsedTaskData({
    required this.title,
    this.dueDate,
    this.priority,
    this.categories = const [],
  });
}

class TaskParser {
  static ParsedTaskData parse(String input) {
    String processedTitle = input;
    Priority? foundPriority;
    List<String> foundCategories = [];
    DateTime? foundDueDate;

    final priorityRegex = RegExp(r"\bp:(\bhigh\b|\bmedium\b|\blow\b)\b", caseSensitive: false);
    if (priorityRegex.hasMatch(processedTitle)) {
      final match = priorityRegex.firstMatch(processedTitle)!.group(1)!.toLowerCase();
      if (match == 'high') foundPriority = Priority.high;
      if (match == 'medium') foundPriority = Priority.medium;
      if (match == 'low') foundPriority = Priority.low;
      processedTitle = processedTitle.replaceAll(priorityRegex, '').trim();
    }

    final categoryRegex = RegExp(r"#(\w+)\b");
    categoryRegex.allMatches(processedTitle).forEach((match) {
      foundCategories.add(match.group(1)!);
    });
    processedTitle = processedTitle.replaceAll(categoryRegex, '').trim();

    final now = DateTime.now();
    DateTime baseDate = DateUtils.dateOnly(now);
    TimeOfDay time = const TimeOfDay(hour: 9, minute: 0);
    bool dateFound = false;
    bool timeFound = false;

    final timeRegex = RegExp(r'(?:at|by)\s*(\d{1,2})(?::(\d{2}))?\s*(am|pm)?\b', caseSensitive: false);
    final timeMatch = timeRegex.firstMatch(processedTitle);
    if (timeMatch != null) {
      int hour = int.parse(timeMatch.group(1)!);
      int minute = timeMatch.group(2) != null ? int.parse(timeMatch.group(2)!) : 0;
      final ampm = timeMatch.group(3)?.toLowerCase();
      if (ampm == 'pm' && hour < 12) hour += 12;
      if (ampm == 'am' && hour == 12) hour = 0;
      time = TimeOfDay(hour: hour, minute: minute);
      processedTitle = processedTitle.replaceAll(timeRegex, '').trim();
      dateFound = true;
      timeFound = true;
    }

    if (RegExp(r'\btomorrow\b', caseSensitive: false).hasMatch(processedTitle)) {
      baseDate = DateUtils.dateOnly(now.add(const Duration(days: 1)));
      processedTitle = processedTitle.replaceAll(RegExp(r'\btomorrow\b', caseSensitive: false), '').trim();
      dateFound = true;
    } else if (RegExp(r'\btoday\b', caseSensitive: false).hasMatch(processedTitle)) {
      baseDate = DateUtils.dateOnly(now);
      processedTitle = processedTitle.replaceAll(RegExp(r'\btoday\b', caseSensitive: false), '').trim();
      dateFound = true;
    }

    if (dateFound) {
      final finalTime = timeFound ? time : const TimeOfDay(hour: 9, minute: 0);
      foundDueDate = DateTime(baseDate.year, baseDate.month, baseDate.day, finalTime.hour, finalTime.minute);
    }

    processedTitle = processedTitle.replaceAll(RegExp(r'\s+'), ' ').trim();

    return ParsedTaskData(
      title: processedTitle,
      priority: foundPriority,
      categories: foundCategories,
      dueDate: foundDueDate,
    );
  }
}

// --- /lib/src/features/tasks/presentation/add_task_screen.dart ---
class AddTaskScreen extends StatefulWidget {
  final String? prefilledTitle;
  const AddTaskScreen({super.key, this.prefilledTitle});
  @override State<AddTaskScreen> createState() => _AddTaskScreenState();
}

class _AddTaskScreenState extends State<AddTaskScreen> {
  final _key = GlobalKey<FormState>(); final _tCtrl = TextEditingController(); final _dCtrl = TextEditingController(); final _titleFocusNode = FocusNode();
  DateTime? _date;
  Priority? _prio;
  List<String> _categories = [];
  bool _isSaving = false;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final taskManager = context.read<TaskManager>();
      setState(() { _prio = taskManager.defaultPriority; });
      _loadAndPromptDraft();
    });

    if (widget.prefilledTitle != null) {
      _tCtrl.text = widget.prefilledTitle!;
    }

    _titleFocusNode.addListener(_onTitleFocusChange);
  }

  Future<void> _loadAndPromptDraft() async {
    final taskManager = context.read<TaskManager>();
    final draft = await taskManager.loadTaskDraft();
    if (draft != null && mounted) {
      final bool? restore = await showDialog<bool>(context: context, builder: (ctx) => AlertDialog(title: const Text('Restore Draft?'), content: const Text('You have an unsaved task draft. Would you like to restore it?'), actions: [TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('Discard')), ElevatedButton(onPressed: () => Navigator.of(ctx).pop(true), child: const Text('Restore'))]));
      if (restore == true && mounted) {
        setState(() {
          _tCtrl.text = draft['title'] ?? '';
          _dCtrl.text = draft['description'] ?? '';
          _categories = (draft['categories'] as List<dynamic>?)?.cast<String>() ?? [];
          final dueDateStr = draft['dueDate'] as String?;
          _date = dueDateStr != null ? DateTime.tryParse(dueDateStr) : null;
          final prioIndex = draft['priority'] as int?;
          _prio = (prioIndex != null && prioIndex >= 0 && prioIndex < Priority.values.length) ? Priority.values[prioIndex] : Priority.medium;
        });
      }
      await taskManager.clearTaskDraft();
    }
  }

  void _onTitleFocusChange() {
    if (!_titleFocusNode.hasFocus && _tCtrl.text.isNotEmpty) {
      _parseTitleAndApply();
    }
  }

  void _parseTitleAndApply() {
    final input = _tCtrl.text;
    final parsedData = TaskParser.parse(input);

    setState(() {
      _tCtrl.text = parsedData.title;

      if (parsedData.dueDate != null) _date = parsedData.dueDate;
      if (parsedData.priority != null) _prio = parsedData.priority;
      if (parsedData.categories.isNotEmpty) {
        _categories = [...{..._categories, ...parsedData.categories}];
      }
    });

    if (parsedData.dueDate != null || parsedData.priority != null || parsedData.categories.isNotEmpty) {
      HapticFeedback.lightImpact();
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(const SnackBar(
          content: Text('Details parsed from title!'),
          duration: Duration(seconds: 2),
        ));
    }
  }

  @override void dispose() {
    if (!_isSaving && (_tCtrl.text.trim().isNotEmpty || _dCtrl.text.trim().isNotEmpty)) {
      context.read<TaskManager>().saveTaskDraft(title: _tCtrl.text, description: _dCtrl.text, categories: _categories.join(','), dueDate: _date, priority: _prio);
    }
    _tCtrl.dispose(); _dCtrl.dispose();
    _titleFocusNode.removeListener(_onTitleFocusChange);
    _titleFocusNode.dispose();
    super.dispose();
  }

  Future<void> _saveTask({bool addAnother = false}) async {
    FocusScope.of(context).unfocus();
    if (_key.currentState!.validate()) {
      setState(() => _isSaving = true);
      final taskManager = context.read<TaskManager>();
      try {
        await taskManager.addTask(
            title: _tCtrl.text.trim(),
            description: _dCtrl.text.trim().isNotEmpty ? _dCtrl.text.trim() : null,
            dueDate: _date,
            priority: _prio ?? Priority.medium,
            categories: _categories.isNotEmpty ? _categories : null
        );
        await taskManager.clearTaskDraft();
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Task Added!'), backgroundColor: Colors.green, duration: Duration(seconds: 2)));
          if (addAnother) {
            _key.currentState?.reset();
            _tCtrl.clear(); _dCtrl.clear();
            setState(() { _categories.clear(); _date = null; _prio = taskManager.defaultPriority; });
            FocusScope.of(context).requestFocus(_titleFocusNode);
          } else {
            Navigator.pop(context);
          }
        }
      } catch (e) {
        if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Failed to add task: $e'), backgroundColor: Colors.red));
      } finally {
        if (mounted) setState(() => _isSaving = false);
      }
    }
  }

  Future<void> _pickDate() async {
    FocusScope.of(context).unfocus();
    final pDate = await showDatePicker(context: context, initialDate: _date ?? DateTime.now(), firstDate: DateTime(2020), lastDate: DateTime(2030));
    if (pDate != null && mounted) {
      final pTime = await showTimePicker(context: context, initialTime: TimeOfDay.fromDateTime(_date ?? DateTime.now().add(const Duration(hours: 1))));
      if (mounted) setState(() => _date = DateTime(pDate.year, pDate.month, pDate.day, pTime?.hour ?? 9, pTime?.minute ?? 0));
    }
  }

  @override
  Widget build(BuildContext c) {
    return Scaffold(
        appBar: AppBar(
            title: const Text('Add New Task'),
            actions: [
              IconButton(
                icon: const Icon(Icons.auto_awesome),
                tooltip: 'Parse Title',
                onPressed: _parseTitleAndApply,
              )
            ]
        ),
        body: SingleChildScrollView(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 100),
            child: Form(
                key: _key,
                child: Column(crossAxisAlignment: CrossAxisAlignment.stretch, children: [
                  TaskFormField(
                    controller: _tCtrl,
                    focusNode: _titleFocusNode,
                    labelText: 'Title *',
                    hintText: 'Task name p:high #tag tomorrow at 2pm',
                    validator: (v) => (v == null || v.trim().isEmpty) ? 'Required' : null,
                    textCapitalization: TextCapitalization.sentences,
                    textInputAction: TextInputAction.next,
                    autofocus: widget.prefilledTitle == null,
                  ),
                  const SizedBox(height: 20),
                  TaskFormField(controller: _dCtrl, labelText: 'Description', maxLines: 4, textCapitalization: TextCapitalization.sentences, keyboardType: TextInputType.multiline, textInputAction: TextInputAction.next),
                  const SizedBox(height: 20),
                  // NEW: Category Input UI
                  CategoryInput(
                    selectedCategories: _categories,
                    onChanged: (newCategories) {
                      setState(() {
                        _categories = newCategories;
                      });
                    },
                  ),
                  const SizedBox(height: 20),
                  ListTile(contentPadding: EdgeInsets.zero, leading: const Icon(Icons.calendar_today), title: Text(_date == null ? 'Add Due Date' : DateFormat.yMd().add_jm().format(_date!)), trailing: _date != null ? IconButton(icon: const Icon(Icons.clear), onPressed: () => setState(() => _date = null)) : null, onTap: _pickDate, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10), side: BorderSide(color: Theme.of(c).colorScheme.outline.withOpacity(0.5)))),
                  const SizedBox(height: 20),
                  DropdownButtonFormField<Priority>(value: _prio, decoration: const InputDecoration(labelText: 'Priority', prefixIcon: Icon(Icons.flag)), items: Priority.values.map((p) => DropdownMenuItem(value: p, child: Text(p.name[0].toUpperCase() + p.name.substring(1)))).toList(), onChanged: (p) { if (p != null) setState(() => _prio = p); }),
                  const SizedBox(height: 35),
                  ElevatedButton.icon(icon: const Icon(Icons.check), onPressed: _isSaving ? null : () => _saveTask(addAnother: false), label: const Text('Save Task')),
                  const SizedBox(height: 12),
                  OutlinedButton.icon(icon: const Icon(Icons.add), onPressed: _isSaving ? null : () => _saveTask(addAnother: true), label: const Text('Save & Add Another'))
                ]))
        ));
  }
}

// --- /lib/src/features/tasks/presentation/task_detail_screen.dart ---
class TaskDetailScreen extends StatefulWidget { final String taskId; const TaskDetailScreen({super.key, required this.taskId}); @override State<TaskDetailScreen> createState() => _TaskDetailScreenState(); }
class _TaskDetailScreenState extends State<TaskDetailScreen> {
  final _formKey = GlobalKey<FormState>(); late TextEditingController _titleController; late TextEditingController _descriptionController;
  DateTime? _selectedDate; Priority? _selectedPriority; TaskStatus? _selectedStatus; RecurrenceRule? _recurrence;
  List<String> _categories = [];
  List<Subtask> _subtasks = []; List<Attachment> _attachments = []; List<String> _linkedNoteIds = [];
  bool _isInitialized = false; bool _isLoadingError = false; Task? _currentTask; StreamSubscription? _taskSubscription;
  final AppLogger _logger = AppLogger();

  @override void initState() { super.initState(); _initializeControllers(); _subscribeToTask(); }
  @override void dispose() { _disposeControllers(); _taskSubscription?.cancel(); super.dispose(); }
  void _initializeControllers() { _titleController = TextEditingController(); _descriptionController = TextEditingController(); }
  void _disposeControllers() { _titleController.dispose(); _descriptionController.dispose(); }

  void _subscribeToTask() {
    final docRef = FirebaseFirestore.instance.collection(Constants.tasksCollection).doc(widget.taskId);
    _taskSubscription = docRef.snapshots().listen((doc) {
      if (doc.exists && mounted) {
        final task = Task.fromFirestore(doc as DocumentSnapshot<Map<String, dynamic>>);
        _updateStateFromTask(task);
        if (!_isInitialized) setState(() => _isInitialized = true);
      } else if (mounted) { setState(() { _isInitialized = true; _isLoadingError = true; }); }
    }, onError: (e) {
      if (mounted) setState(() { _isInitialized = true; _isLoadingError = true; _logger.log("Error subscribing to task: $e");});
    });
  }

  void _updateStateFromTask(Task task) {
    if (!mounted) return;
    setState(() {
      _currentTask = task;
      if (_titleController.text != task.title) _titleController.text = task.title;
      if (_descriptionController.text != (task.description ?? '')) _descriptionController.text = task.description ?? '';
      _categories = task.categories ?? [];
      _selectedDate = task.dueDate; _selectedPriority = task.priority; _selectedStatus = task.status;
      _subtasks = task.subtasks.map((s) => Subtask.fromMap(s.toMap())).toList();
      _attachments = List.from(task.attachments);
      _linkedNoteIds = List.from(task.linkedNoteIds ?? []);
      _recurrence = task.recurrence;
    });
  }

  Future<void> _updateTaskDetails() async {
    FocusScope.of(context).unfocus(); if (!_formKey.currentState!.validate() || _currentTask == null) return;
    final taskManager = context.read<TaskManager>();
    Task updatedTask = _currentTask!.copyWith(
      title: _titleController.text.trim(),
      description: _descriptionController.text.trim().isNotEmpty ? _descriptionController.text.trim() : null, setDescriptionNull: _descriptionController.text.trim().isEmpty,
      dueDate: _selectedDate, setDueDateNull: _selectedDate == null,
      priority: _selectedPriority,
      categories: _categories.isNotEmpty ? _categories : null, setCategoriesNull: _categories.isEmpty,
      subtasks: _subtasks,
      attachments: _attachments,
      recurrence: _recurrence, setRecurrenceNull: _recurrence == null,
    );
    await taskManager.updateTask(updatedTask);
    if (mounted) { Navigator.pop(context); ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Task details updated!'))); }
  }

  Future<void> _handleStatusChange(TaskStatus newStatus) async { if (_currentTask == null || _selectedStatus == newStatus) return; final taskManager = context.read<TaskManager>(); await taskManager.updateTaskStatus(_currentTask!.id, newStatus); if (mounted && newStatus == TaskStatus.completed) { ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("'${_currentTask!.title}' marked complete!"), backgroundColor: Colors.green)); } }
  Future<void> _pickDueDate() async { FocusScope.of(context).unfocus(); final pDate = await showDatePicker(context: context, initialDate: _selectedDate ?? DateTime.now(), firstDate: DateTime(DateTime.now().year - 1), lastDate: DateTime(DateTime.now().year + 5)); if (pDate != null && mounted) { final pTime = await showTimePicker(context: context, initialTime: TimeOfDay.fromDateTime(_selectedDate ?? DateTime.now().add(const Duration(hours: 1)))); if (mounted) setState(() => _selectedDate = DateTime(pDate.year, pDate.month, pDate.day, pTime?.hour ?? 9, pTime?.minute ?? 0)); } }
  Future<void> _archiveTask() async { if (_currentTask == null) return; final confirm = await showDialog<bool>(context: context, builder: (ctx) => AlertDialog(title: const Text('Confirm Archive'), content: Text('Archive "${_currentTask!.title}"?'), actions: [TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('Cancel')), TextButton(onPressed: () => Navigator.of(ctx).pop(true), style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.secondary), child: const Text('Archive'))])); if (confirm == true && mounted) { final taskManager = context.read<TaskManager>(); await taskManager.archiveTask(_currentTask!.id); if (mounted) { Navigator.pop(context); ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Task '${_currentTask!.title}' archived."), duration: const Duration(seconds: 4), action: SnackBarAction(label: "UNDO", onPressed: () => taskManager.undoArchiveTask()))); } } }


  Future<void> _addSubtask() async {
    final newSubtask = await Navigator.push<Subtask>(
      context,
      MaterialPageRoute(builder: (context) => const AddSubtaskScreen()),
    );

    if (newSubtask != null && mounted) {
      setState(() {
        _subtasks.add(newSubtask);
      });
      HapticFeedback.lightImpact();
    }
  }

  void _showRecurrenceDialog() {
    showDialog(context: context, builder: (ctx) => RecurrenceDialog(
      initialRule: _recurrence,
      onSave: (rule) => setState(() => _recurrence = rule),
    ));
  }

  // In your TaskDetailScreen widget

  Future<void> _attachFile() async {
    // FINAL FIX: Add this check at the very top of the function.
    if (kIsWeb) {
      _logger.log("Local file attachments are not supported on web.");
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(
          content: const Text('File attachments are not available on the web version.'),
          backgroundColor: Theme.of(context).colorScheme.error,
        ));
      }
      return; // Stop the function immediately for web
    }

    // The rest of the original code will now only run on mobile.
    FilePickerResult? result = await FilePicker.platform.pickFiles(type: FileType.any);
    if (result != null && result.files.single.path != null) {
      try {
        File sourceFile = File(result.files.single.path!);
        final appDir = await getApplicationDocumentsDirectory();
        final fileName = p_path.basename(sourceFile.path);
        final newPath = p_path.join(appDir.path, fileName);
        final newFile = await sourceFile.copy(newPath);

        final type = _getAttachmentType(fileName);

        setState(() {
          _attachments.add(Attachment(id: const Uuid().v4(), localPath: newFile.path, fileName: fileName, type: type));
        });
        HapticFeedback.lightImpact();
      } catch (e) {
        _logger.log("Error attaching file: $e");
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(SnackBar(
            content: Text('Error attaching file: ${e.toString()}'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ));
        }
      }
    }
  }

  // In your TaskDetailScreen widget

  Future<void> _viewAttachment(Attachment attachment) async {
    // Add this conditional check
    if (kIsWeb) {
      _logger.log("Local file viewing is not supported on web.");
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(
          content: const Text('Local file preview is not supported on web.'),
          backgroundColor: Theme.of(context).colorScheme.error,
        ));
      }
      return;
    }

    // The rest of your original code for mobile goes here
    final file = File(attachment.localPath);

    if (!await file.exists()) {
      _logger.log("File does not exist at path: ${attachment.localPath}");
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(
          content: Text('Could not open file. It may be missing or deleted.'),
          backgroundColor: Theme.of(context).colorScheme.error,
        ));
      }
      return;
    }

    _logger.log("Attempting to open file: ${file.path}");

    try {
      if (attachment.type == AttachmentType.image) {
        Navigator.push(context, MaterialPageRoute(builder: (_) => ImageViewerScreen(imagePath: file.path)));
      } else if (attachment.type == AttachmentType.pdf) {
        Navigator.push(context, MaterialPageRoute(builder: (_) => PdfViewerScreen(filePath: file.path)));
      } else {
        final result = await OpenAppFile.open(file.path);
        if (result.type != ResultType.done) {
          _logger.log("Error opening file with open_app_file: ${result.message}");
          throw Exception(result.message);
        }
      }
    } catch (e) {
      _logger.log("Error viewing attachment: $e");
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(
          content: const Text('Could not open this file type. No application found.'),
          backgroundColor: Theme.of(context).colorScheme.error,
        ));
      }
    }
  }

  void _linkNote() {
    showDialog(
      context: context,
      builder: (ctx) => LinkNoteDialog(
        taskId: widget.taskId,
        alreadyLinkedNoteIds: _linkedNoteIds,
      ),
    );
  }

  AttachmentType _getAttachmentType(String fileName) {
    final ext = p_path.extension(fileName).toLowerCase();
    if (['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'].contains(ext)) return AttachmentType.image;
    if (ext == '.pdf') return AttachmentType.pdf;
    if (['.m4a', '.mp3', '.wav', '.aac'].contains(ext)) return AttachmentType.audio;
    return AttachmentType.other;
  }

  @override
  Widget build(BuildContext context) {
    if (!_isInitialized) return Scaffold(appBar: AppBar(title: const Text('Loading...')), body: const Center(child: CircularProgressIndicator()));
    if (_isLoadingError || _currentTask == null) return Scaffold(appBar: AppBar(title: const Text('Error')), body: Center(child: Text("Task not found or an error occurred.", style: Theme.of(context).textTheme.titleLarge)));
    final noteManager = context.watch<NoteManager>();

    return Scaffold(
        appBar: AppBar(
            title: const Text('Task Details'),
            actions: [
              IconButton(icon: const Icon(Icons.archive_outlined), tooltip: "Archive Task", onPressed: _archiveTask),
              IconButton(icon: const Icon(Icons.save_alt_outlined), tooltip: "Save Changes", onPressed: _updateTaskDetails)
            ]),
        body: SingleChildScrollView(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 120),
            child: Form(key: _formKey, child: Column(crossAxisAlignment: CrossAxisAlignment.stretch, children: [
              TaskFormField(controller: _titleController, labelText: 'Title *', validator: (v) => (v == null || v.trim().isEmpty) ? 'Required' : null), const SizedBox(height: 20),
              TaskFormField(controller: _descriptionController, labelText: 'Description', maxLines: 4),
              const Divider(height: 30),

              _buildSectionHeader(context, "Linked Notes"),
              if(_linkedNoteIds.isEmpty) const Text("No notes linked.", style: TextStyle(color: Colors.grey)),
              if(_linkedNoteIds.isNotEmpty) Wrap(spacing: 8, runSpacing: 8, children: _linkedNoteIds.map((noteId) {
                final note = noteManager.getNoteById(noteId);
                if (note == null) return const SizedBox.shrink();
                return InkWell(
                  onTap: () => Navigator.pushNamed(context, Constants.noteDetailRoute, arguments: noteId),
                  child: Chip(
                    avatar: const Icon(Icons.sticky_note_2_outlined, size: 18),
                    label: Text(note.title),
                    onDeleted: () async {
                      await context.read<FirestoreService>().unlinkTaskAndNote(widget.taskId, noteId);
                    },
                    deleteIconColor: Theme.of(context).colorScheme.onSurfaceVariant.withOpacity(0.7),
                    deleteButtonTooltipMessage: "Unlink Note",
                    visualDensity: VisualDensity.compact,
                  ),
                );
              }).toList()),
              TextButton.icon(onPressed: _linkNote, icon: const Icon(Icons.link_rounded), label: const Text("Link a Note")),
              const Divider(height: 30),

              _buildSectionHeader(context, "Subtasks"),
              if(_subtasks.isNotEmpty) LinearPercentIndicator(percent: _currentTask!.progress, lineHeight: 8, barRadius: const Radius.circular(4), progressColor: Theme.of(context).colorScheme.primary),
              if(_subtasks.isNotEmpty) const SizedBox(height: 8),
              if(_subtasks.isNotEmpty) ReorderableListView(
                shrinkWrap: true, physics: const NeverScrollableScrollPhysics(),
                children: _subtasks.map((s) => _buildSubtaskTile(s)).toList(),
                onReorder: (oldIndex, newIndex) {
                  setState(() { if(oldIndex < newIndex) newIndex -= 1; final item = _subtasks.removeAt(oldIndex); _subtasks.insert(newIndex, item); });
                },
              ),
              TextButton.icon(onPressed: _addSubtask, icon: const Icon(Icons.add), label: const Text("Add Subtask")),
              const Divider(height: 30),

              _buildSectionHeader(context, "Attachments"),
              _attachments.isEmpty ? const Text("No attachments.", style: TextStyle(color: Colors.grey))
                  : Wrap(spacing: 8, runSpacing: 8, children: _attachments.map((a) => AttachmentChip(
                attachment: a,
                onPressed: () => _viewAttachment(a),
                onDelete: () {
                  setState(()=> _attachments.remove(a));
                },
              )).toList()),
              TextButton.icon(onPressed: _attachFile, icon: const Icon(Icons.attach_file), label: const Text("Attach File")),
              const Divider(height: 30),

              _buildSectionHeader(context, "Details"),
              ListTile(contentPadding: EdgeInsets.zero, leading: const Icon(Icons.calendar_today_outlined), title: Text(_selectedDate == null ? 'Add Due Date' : 'Due: ${DateFormat.yMd().add_jm().format(_selectedDate!)}'), trailing: _selectedDate != null ? IconButton(icon: const Icon(Icons.clear), onPressed: () => setState(() => _selectedDate = null)) : null, onTap: _pickDueDate),
              ListTile(contentPadding: EdgeInsets.zero, leading: const Icon(Icons.repeat_rounded), title: Text(_recurrence?.description ?? "Set Recurrence"), onTap: _showRecurrenceDialog, trailing: _recurrence != null ? IconButton(icon: const Icon(Icons.clear), onPressed: ()=>setState(()=>_recurrence = null)) : null),
              DropdownButtonFormField<Priority>(value: _selectedPriority, decoration: const InputDecoration(labelText: 'Priority', border: InputBorder.none, contentPadding: EdgeInsets.zero, prefixIcon: Icon(Icons.flag_outlined)), items: Priority.values.map((p) => DropdownMenuItem(value: p, child: Text(p.name[0].toUpperCase() + p.name.substring(1)))).toList(), onChanged: (p) => setState(() => _selectedPriority=p)),
              CategoryInput(
                selectedCategories: _categories,
                onChanged: (newCategories) {
                  setState(() {
                    _categories = newCategories;
                  });
                },
              ),
            ]))),
        bottomNavigationBar: _buildBottomBar(context));
  }

  Padding _buildSectionHeader(BuildContext context, String title) => Padding(padding: const EdgeInsets.symmetric(vertical: 8), child: Text(title.toUpperCase(), style: Theme.of(context).textTheme.labelSmall?.copyWith(color: Theme.of(context).colorScheme.primary, fontWeight: FontWeight.bold)));
  Widget _buildSubtaskTile(Subtask subtask) {
    final subtaskCtrl = TextEditingController(text: subtask.title);
    return ListTile(
      key: ValueKey(subtask.id),
      contentPadding: EdgeInsets.zero,
      leading: Checkbox(value: subtask.isCompleted, onChanged: (val) {setState(() => subtask.isCompleted = val ?? false); HapticFeedback.lightImpact();}),
      title: TextFormField(controller: subtaskCtrl, onChanged: (val) => subtask.title = val, decoration: const InputDecoration(border: InputBorder.none)),
      trailing: IconButton(icon: const Icon(Icons.delete_outline), onPressed: () => setState(()=>_subtasks.remove(subtask)),),
    );
  }
  Widget _buildBottomBar(BuildContext context) { return Padding(padding: const EdgeInsets.all(12.0), child: SegmentedButton<TaskStatus>(segments: const <ButtonSegment<TaskStatus>>[ButtonSegment<TaskStatus>(value: TaskStatus.notStarted, label: Text('To Do'), icon: Icon(Icons.radio_button_unchecked)), ButtonSegment<TaskStatus>(value: TaskStatus.inProgress, label: Text('In Progress'), icon: Icon(Icons.data_usage_rounded)), ButtonSegment<TaskStatus>(value: TaskStatus.completed, label: Text('Done'), icon: Icon(Icons.check))], selected: {_selectedStatus!}, onSelectionChanged: (Set<TaskStatus> newSelection) => _handleStatusChange(newSelection.first))); }
}

// --- /lib/src/features/settings/presentation/settings_screen.dart ---
class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});
  String _getThemeModeName(ThemeMode mode) => mode.name[0].toUpperCase() + mode.name.substring(1);
  String _getPriorityName(Priority priority) => priority.name[0].toUpperCase() + priority.name.substring(1);

  @override
  Widget build(BuildContext context) {
    final themeManager = Provider.of<ThemeManager>(context);
    final taskManager = Provider.of<TaskManager>(context);

    return Scaffold(
        appBar: AppBar(title: const Text("Settings")),
        body: ListView(
            children: [
              _buildSectionHeader(context, "General"),
              ListTile(
                  leading: const Icon(Icons.account_circle_outlined),
                  title: const Text('Account'),
                  subtitle: const Text('Manage your profile and security'),
                  onTap: () => Navigator.pushNamed(context, Constants.accountRoute)
              ),
              ListTile(
                  leading: const Icon(Icons.brightness_6_outlined),
                  title: const Text("App Theme"),
                  trailing: PopupMenuButton<ThemeMode>(
                      onSelected: themeManager.setThemeMode,
                      itemBuilder: (ctx) => ThemeMode.values.map((mode) => PopupMenuItem(value: mode, child: Text(_getThemeModeName(mode)))).toList(),
                      child: Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
                          child: Text(_getThemeModeName(themeManager.themeMode), style: Theme.of(context).textTheme.bodyLarge?.copyWith(color: Theme.of(context).colorScheme.secondary))
                      )
                  )
              ),
              const Divider(),
              _buildSectionHeader(context, "Tasks"),
              // NEW: Link to Category Management Screen
              ListTile(
                  leading: const Icon(Icons.category_outlined),
                  title: const Text("Manage Categories"),
                  subtitle: const Text('Create and edit your custom task categories'),
                  onTap: () => Navigator.pushNamed(context, Constants.manageCategoriesRoute)
              ),
              ListTile(
                  leading: const Icon(Icons.star_outline_rounded),
                  title: const Text("Default Task Priority"),
                  subtitle: const Text("Smartly chosen based on your habits."),
                  trailing: PopupMenuButton<Priority>(
                      onSelected: (prio) {
                        taskManager.setDefaultPriority(prio);
                        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Default priority set to ${_getPriorityName(prio)}')));
                      },
                      itemBuilder: (ctx) => Priority.values.map((p) => PopupMenuItem<Priority>(value: p, child: Text(_getPriorityName(p)))).toList(),
                      child: Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
                          child: Text(_getPriorityName(taskManager.defaultPriority), style: Theme.of(context).textTheme.bodyLarge?.copyWith(color: Theme.of(context).colorScheme.secondary))
                      )
                  )
              ),
              ListTile(
                  leading: const Icon(Icons.bar_chart_rounded),
                  title: const Text('Task Statistics'),
                  subtitle: const Text('View your productivity insights.'),
                  onTap: () => Navigator.pushNamed(context, Constants.statsRoute)
              ),
              ListTile(
                  leading: const Icon(Icons.inventory_2_outlined),
                  title: const Text('Archived Tasks'),
                  subtitle: const Text('View or restore archived tasks.'),
                  onTap: () => Navigator.pushNamed(context, Constants.archivedTasksRoute)
              ),
              const Divider(),
              _buildSectionHeader(context, "About & Legal"),
              ListTile(
                  leading: const Icon(Icons.info_outline),
                  title: const Text('About NisanApp'),
                  onTap: () => Navigator.pushNamed(context, Constants.aboutRoute)
              ),
              ListTile(
                  leading: const Icon(Icons.gavel_rounded),
                  title: const Text('Terms of Service'),
                  onTap: () => Navigator.pushNamed(context, Constants.termsRoute)
              ),
              ListTile(
                  leading: const Icon(Icons.shield_outlined),
                  title: const Text('Privacy Policy'),
                  onTap: () => Navigator.pushNamed(context, Constants.privacyPolicyRoute)
              ),
            ]
        )
    );
  }
  Padding _buildSectionHeader(BuildContext context, String title) { return Padding(padding: const EdgeInsets.fromLTRB(16, 16, 16, 8), child: Text(title.toUpperCase(), style: Theme.of(context).textTheme.labelSmall?.copyWith(color: Theme.of(context).colorScheme.primary, fontWeight: FontWeight.bold))); }
}

// --- /lib/src/features/stats/presentation/stats_screen.dart ---
// --- /lib/src/features/stats/presentation/stats_screen.dart ---
class StatsScreen extends StatelessWidget {
  const StatsScreen({super.key});
  static const List<String> _productivityTips = ["Break large tasks into smaller, manageable sub-tasks.", "Use the 2-Minute Rule: If a task takes less than two minutes, do it now.", "Prioritize your tasks using a method like the Eisenhower Matrix (Urgent/Important).", "Take regular breaks to stay focused and avoid burnout. The Pomodoro Technique is great for this.", "Batch similar tasks together to minimize context switching.", "Set clear, specific goals for what you want to accomplish each day.", "Review your completed tasks at the end of the day to feel a sense of accomplishment.", "Minimize distractions. Turn off notifications when you need to focus.", "Celebrate your wins, no matter how small!"];
  String _getRandomTip() { final random = Random(); return _productivityTips[random.nextInt(_productivityTips.length)]; }
  String _formatFocusTime(int totalMinutes) {
    if (totalMinutes < 60) return "$totalMinutes min";
    final hours = totalMinutes ~/ 60;
    final minutes = totalMinutes % 60;
    return '${hours}h ${minutes}m';
  }

  @override
  Widget build(BuildContext context) { return Scaffold(appBar: AppBar(title: const Text('Task Statistics')), body: Consumer<TaskManager>(builder: (context, taskManager, child) { if (taskManager.isLoading) return const Center(child: CircularProgressIndicator()); if (taskManager.totalTaskCount == 0) return Center(child: Column(mainAxisAlignment: MainAxisAlignment.center, children: [const Icon(Icons.bar_chart_outlined, size: 80, color: Colors.grey), const SizedBox(height: 16), Text("No Statistics Yet", style: Theme.of(context).textTheme.headlineSmall), const Text("Complete some tasks to see your stats!", style: TextStyle(color: Colors.grey))])); return ListView(padding: const EdgeInsets.all(16), children: [
    _buildPriorityPieChart(context, taskManager),
    const SizedBox(height: 24),
    _buildWeeklyCompletionChart(context, taskManager),
    const SizedBox(height: 16),
    const Divider(),
    const SizedBox(height: 16),
    _buildStatCard(context, icon: Icons.functions, title: 'Total Active Tasks', value: taskManager.totalTaskCount.toString(), color: Theme.of(context).colorScheme.primary),
    _buildStatCard(context, icon: Icons.check_circle_outline, title: 'Completed', value: taskManager.completedTaskCount.toString(), color: Colors.green.shade600),
    _buildStatCard(context, icon: Icons.data_usage_rounded, title: 'In Progress', value: taskManager.inProgressTaskCount.toString(), color: Colors.blue.shade600),
    _buildStatCard(context, icon: Icons.radio_button_unchecked, title: 'To Do', value: (taskManager.totalTaskCount - taskManager.completedTaskCount - taskManager.inProgressTaskCount).toString(), color: Colors.grey.shade600),
    const SizedBox(height: 16),
    _buildStatCard(context, icon: Icons.whatshot_rounded, title: 'Current Streak', value: '${taskManager.currentStreak} Days', color: Colors.deepOrange.shade600),
    _buildStatCard(context, icon: Icons.av_timer_rounded, title: 'Total Focus Time', value: _formatFocusTime(taskManager.totalFocusTime), color: Theme.of(context).colorScheme.tertiary),
    _buildStatCard(context, icon: Icons.timelapse_rounded, title: 'Focus Sessions', value: taskManager.totalFocusSessions.toString(), color: Theme.of(context).colorScheme.tertiary),
    const SizedBox(height: 16),
    _buildStatCard(context, icon: Icons.calendar_today_rounded, title: 'Completed This Week', value: taskManager.completedThisWeekCount.toString(), color: Colors.deepOrange.shade500),
    _buildStatCard(context, icon: Icons.calendar_view_week_rounded, title: 'Most Productive Day', value: taskManager.mostProductiveDay, color: Colors.purple.shade500), const SizedBox(height: 24), const Divider(), const SizedBox(height: 16), _buildTipCard(context, _getRandomTip())]); })); }

  Widget _buildStatCard(BuildContext context, {required IconData icon, required String title, required String value, required Color color}) { final theme = Theme.of(context); return Card(margin: const EdgeInsets.symmetric(vertical: 4.0), elevation: 0.5, child: Padding(padding: const EdgeInsets.all(16.0), child: Row(children: [Icon(icon, size: 32, color: color), const SizedBox(width: 16), Expanded(child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [Text(title, style: theme.textTheme.titleMedium), const SizedBox(height: 4), Text(value, style: theme.textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold, color: color), overflow: TextOverflow.ellipsis)]))]))); }
  Widget _buildTipCard(BuildContext context, String tip) { final theme = Theme.of(context); return Card(elevation: 0, color: theme.colorScheme.tertiaryContainer.withOpacity(0.5), shape: RoundedRectangleBorder(side: BorderSide(color: theme.colorScheme.tertiaryContainer, width: 1), borderRadius: BorderRadius.circular(12)), child: Padding(padding: const EdgeInsets.all(16.0), child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [Row(children: [Icon(Icons.lightbulb_outline_rounded, color: theme.colorScheme.onTertiaryContainer), const SizedBox(width: 8), Text("Productivity Tip", style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold, color: theme.colorScheme.onTertiaryContainer))]), const SizedBox(height: 12), Text(tip, style: theme.textTheme.bodyLarge?.copyWith(color: theme.colorScheme.onTertiaryContainer))]))); }

  Widget _buildPriorityPieChart(BuildContext context, TaskManager taskManager) {
    final theme = Theme.of(context);
    final Map<String, double> dataMap = {
      "High": taskManager.highPriorityTaskCount.toDouble(),
      "Medium": taskManager.mediumPriorityTaskCount.toDouble(),
      "Low": taskManager.lowPriorityTaskCount.toDouble(),
    };

    final colorList = <Color>[
      theme.colorScheme.error.withOpacity(0.8),
      theme.colorScheme.tertiary.withOpacity(0.8),
      theme.colorScheme.outline.withOpacity(0.8),
    ];

    final validDataMap = Map.fromEntries(dataMap.entries.where((entry) => entry.value > 0));
    if (validDataMap.isEmpty) return const SizedBox.shrink();

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text("Task Priority Distribution", style: theme.textTheme.titleLarge),
            const SizedBox(height: 20),
            SizedBox(
              height: 150,
              child: PieChart(
                dataMap: validDataMap,
                animationDuration: const Duration(milliseconds: 800),
                chartLegendSpacing: 32,
                chartRadius: MediaQuery.of(context).size.width / 3.2,
                colorList: colorList,
                initialAngleInDegree: -90,
                chartType: ChartType.ring,
                ringStrokeWidth: 24,
                centerText: "Priorities",
                legendOptions: const LegendOptions(
                  showLegendsInRow: false,
                  legendPosition: LegendPosition.right,
                  showLegends: true,
                  legendTextStyle: TextStyle(fontWeight: FontWeight.bold),
                ),
                chartValuesOptions: const ChartValuesOptions(
                  showChartValueBackground: false,
                  showChartValues: true,
                  showChartValuesInPercentage: false,
                  showChartValuesOutside: true,
                  decimalPlaces: 0,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  // FIXED WIDGET
  Widget _buildWeeklyCompletionChart(BuildContext context, TaskManager taskManager) {
    final theme = Theme.of(context);
    final weeklyData = taskManager.weeklyCompletionData;
    final maxValue = weeklyData.values.fold(0, (max, v) => v > max ? v : max).toDouble();

    if (maxValue == 0) {
      return Card(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text("Weekly Completion", style: theme.textTheme.titleLarge),
              const SizedBox(height: 24),
              SizedBox(
                height: 170,
                child: Center(
                  child: Text(
                    "Complete some tasks to see your weekly progress!",
                    textAlign: TextAlign.center,
                    style: TextStyle(color: theme.colorScheme.outline),
                  ),
                ),
              ),
            ],
          ),
        ),
      );
    }

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text("Weekly Completion", style: theme.textTheme.titleLarge),
            const SizedBox(height: 24),
            SizedBox(
              height: 170, // FIX: Increased height to prevent overflow
              child: LayoutBuilder(
                builder: (context, constraints) {
                  final barWidth = (constraints.maxWidth - (6 * 8)) / 7;
                  return Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    crossAxisAlignment: CrossAxisAlignment.end,
                    children: weeklyData.entries.map((entry) {
                      final day = entry.key;
                      final count = entry.value;
                      // FIX: Reduced max bar height to give more room for text
                      final barHeight = count == 0 ? 4.0 : (count / maxValue) * 110.0;
                      return Column(
                        mainAxisAlignment: MainAxisAlignment.end,
                        children: [
                          Text(count.toString(), style: theme.textTheme.labelSmall?.copyWith(color: theme.colorScheme.primary)),
                          const SizedBox(height: 4),
                          AnimatedContainer(
                            duration: const Duration(milliseconds: 500),
                            curve: Curves.easeOutCubic,
                            width: barWidth,
                            height: barHeight,
                            decoration: BoxDecoration(
                              color: theme.colorScheme.primary,
                              borderRadius: const BorderRadius.vertical(top: Radius.circular(4)),
                            ),
                          ),
                          const SizedBox(height: 8),
                          Text(day, style: theme.textTheme.bodySmall),
                        ],
                      );
                    }).toList(),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// --- /lib/src/features/about/presentation/about_screen.dart ---
class AboutScreen extends StatelessWidget {
  const AboutScreen({super.key});
  Future<void> _launchUrl(BuildContext context, String urlString) async {
    final Uri url = Uri.parse(urlString);
    if (!await launchUrl(url, mode: LaunchMode.externalApplication)) {
      AppLogger().log('Could not launch $url');
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(
          content: Text('Could not open link: $urlString'),
          backgroundColor: Theme.of(context).colorScheme.error,
        ));
      }
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context); final textTheme = theme.textTheme;
    return Scaffold(appBar: AppBar(title: const Text('About NisanApp')), body: ListView(padding: const EdgeInsets.all(16.0), children: <Widget>[
      Center(child: Column(children: [Icon(Icons.task_alt_rounded, size: 60, color: theme.colorScheme.primary), const SizedBox(height: 12), Text('NisanApp', style: textTheme.headlineMedium?.copyWith(fontWeight: FontWeight.bold)), const SizedBox(height: 4), Text('Your Smart Manager & Notebook.', style: textTheme.titleMedium?.copyWith(color: theme.colorScheme.onSurfaceVariant), textAlign: TextAlign.center)])),
      const SizedBox(height: 24), Text('NisanApp is a smart, intuitive application built to elevate your productivity. It integrates task management, spaced repetition, and a powerful notebook into a clean, fluid, and memory-friendly design.', style: textTheme.bodyLarge, textAlign: TextAlign.center),
      const SizedBox(height: 24), const Divider(), const SizedBox(height: 16),
      Text('Why NisanApp Stands Out', style: textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600)), const SizedBox(height: 16),
      _buildFeatureCard(context, icon: Icons.sync_alt_rounded, title: 'Dynamic Workflow Management', points: ['Task Progress Status: Move tasks from "To Do" to "In Progress" and "Completed".', 'Spaced Repetition (SRS): Completed tasks are scheduled for review to reinforce memory.', 'Intelligent Dashboard: Instantly see what’s Overdue, Due Today, or High Priority.']),
      _buildFeatureCard(context, icon: Icons.note_alt_outlined, title: 'Integrated Notebook', points: ['Seamlessly switch between tasks and notes.', 'A simple, clean interface for capturing your thoughts.', 'Auto-saving ensures your ideas are never lost.']),
      _buildFeatureCard(context, icon: Icons.cloud_done_outlined, title: 'Secure & Real-time Cloud Sync', points: ['Firebase Backend: Your data is securely stored and synced in real-time across your devices.', 'Robust Authentication: Secure sign-in powered by Firebase Authentication.', 'Offline Ready: Make changes offline and they will sync when you reconnect.']),
      _buildFeatureCard(context, icon: Icons.design_services_outlined, title: 'Polished & Thoughtful Design', points: ['Fluid Animations: Enjoy a responsive interface with graceful animations.', 'Haptic Feedback: Feel satisfying touch responses on key actions.', 'Auto-Draft & Undo: Never lose an idea with automatic draft saving and undo functionality.']),
      const SizedBox(height: 24), const Divider(), const SizedBox(height: 16), Text('Need Help or Have Feedback?', style: textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600)), const SizedBox(height: 16),
      ListTile(leading: const Icon(Icons.email_outlined), title: const Text('Email Support'), subtitle: const Text('nisanapptechdev@gmail.com'), onTap: () => _launchUrl(context, 'mailto:nisanapptechdev@gmail.com')),
      const SizedBox(height: 32), Center(child: Text('Smarter. Simpler. Sharper.', style: textTheme.titleSmall?.copyWith(fontStyle: FontStyle.italic, color: theme.colorScheme.outline)))]));
  }
  Widget _buildFeatureCard(BuildContext context, {required IconData icon, required String title, required List<String> points}) { return Card(margin: const EdgeInsets.symmetric(vertical: 8), child: Padding(padding: const EdgeInsets.all(16.0), child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [Row(children: [Icon(icon, color: Theme.of(context).colorScheme.primary), const SizedBox(width: 12), Expanded(child: Text(title, style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)))]), const SizedBox(height: 12), ...points.map((point) => Padding(padding: const EdgeInsets.only(bottom: 8.0, left: 4.0), child: Row(crossAxisAlignment: CrossAxisAlignment.start, children: [Text('• ', style: TextStyle(color: Theme.of(context).colorScheme.primary, fontWeight: FontWeight.bold, fontSize: 16)), Expanded(child: Text(point, style: Theme.of(context).textTheme.bodyMedium))])))]))); }
}

// --- /lib/src/features/notes/presentation/notes_view.dart ---
class NotesView extends StatefulWidget {
  const NotesView({super.key});

  @override
  State<NotesView> createState() => _NotesViewState();
}

// --- /lib/src/features/notes/presentation/notes_view.dart ---
class _NotesViewState extends State<NotesView> {
  final ScrollController _scrollController = ScrollController();
  bool _showScrollButton = false;

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(() {
      if (_scrollController.offset > 300 && !_showScrollButton) {
        setState(() => _showScrollButton = true);
      } else if (_scrollController.offset <= 300 && _showScrollButton) {
        setState(() => _showScrollButton = false);
      }
    });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<NoteManager>(
      builder: (context, noteManager, child) {
        if (noteManager.isLoading) { return const Center(child: CircularProgressIndicator()); }
        final notes = noteManager.notes;
        if (notes.isEmpty) { return _buildEmptyState(context); }

        return Stack(
          children: [
            ListView.builder(
              controller: _scrollController,
              padding: const EdgeInsets.fromLTRB(4, 4, 4, 88),
              itemCount: notes.length,
              itemBuilder: (context, index) {
                final note = notes[index];
                return AnimatedListItem(
                  index: index,
                  child: Slidable(
                    key: ValueKey(note.id),
                    startActionPane: ActionPane(
                      motion: const StretchMotion(),
                      children: [
                        SlidableAction(
                          onPressed: (ctx) {
                            final updatedNote = note.copyWith(isPinned: !note.isPinned);
                            noteManager.updateNote(updatedNote);
                            ScaffoldMessenger.of(context)..hideCurrentSnackBar()..showSnackBar(SnackBar(content: Text(updatedNote.isPinned ? "Note Pinned" : "Note Unpinned")));
                          },
                          backgroundColor: Theme.of(context).colorScheme.tertiary, foregroundColor: Colors.white,
                          icon: note.isPinned ? Icons.push_pin : Icons.push_pin_outlined, label: note.isPinned ? 'Unpin' : 'Pin',
                        ),
                      ],
                    ),
                    endActionPane: ActionPane(
                      motion: const StretchMotion(),
                      children: [
                        SlidableAction(
                          onPressed: (ctx) => _confirmDelete(context, note, noteManager),
                          backgroundColor: Theme.of(context).colorScheme.error, foregroundColor: Colors.white,
                          icon: Icons.delete, label: 'Delete',
                        ),
                      ],
                    ),
                    child: NoteListItem(
                      note: note,
                      onTap: () => Navigator.pushNamed(context, Constants.noteDetailRoute, arguments: note.id),
                    ),
                  ),
                );
              },
            ),
            Positioned(
              // CORRECTED: Moved from right to left
              bottom: 16,
              left: 16,
              child: AnimatedOpacity(
                opacity: _showScrollButton ? 1.0 : 0.0,
                duration: const Duration(milliseconds: 300),
                child: FloatingActionButton.small(
                  onPressed: () => _scrollController.animateTo(0, duration: const Duration(milliseconds: 500), curve: Curves.easeInOut),
                  tooltip: 'Scroll to top',
                  child: const Icon(Icons.arrow_upward),
                ),
              ),
            ),
          ],
        );
      },
    );
  }

  Future<void> _confirmDelete(BuildContext context, Note note, NoteManager noteManager) async {
    final bool? confirmed = await showDialog<bool>(context: context, builder: (ctx) => AlertDialog(title: const Text('Confirm Deletion'), content: Text('Are you sure you want to delete "${note.title}"?'), actions: [ TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('Cancel')), TextButton(onPressed: () => Navigator.of(ctx).pop(true), style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.error), child: const Text('Delete'))]));
    if (confirmed == true && context.mounted) { await noteManager.deleteNote(note.id); if (context.mounted) { ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("'${note.title}' deleted."))); }
    }
  }

  Widget _buildEmptyState(BuildContext context) {
    return Center(child: Padding(padding: const EdgeInsets.all(30.0), child: Column(mainAxisAlignment: MainAxisAlignment.center, children: [ Icon(Icons.note_add_outlined, size: 70, color: Colors.grey[400]), const SizedBox(height: 20), Text('No Notes Yet', style: Theme.of(context).textTheme.headlineSmall?.copyWith(color: Colors.grey.shade600)), const SizedBox(height: 8), const Text('Tap the "Add" button to create your first note.', style: TextStyle(color: Colors.grey), textAlign: TextAlign.center) ])));
  }
}

// --- /lib/src/features/notes/presentation/widgets/note_list_item.dart ---
class NoteListItem extends StatelessWidget {
  final Note note;
  final VoidCallback onTap;
  const NoteListItem({super.key, required this.note, required this.onTap});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final textTheme = theme.textTheme;
    final cardColor = note.isPinned ? theme.colorScheme.tertiaryContainer.withOpacity(0.4) : theme.cardTheme.color;
    final previewContent = note.content.replaceAll('\n', ' ').trim();

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 5),
      color: cardColor,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12.0),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Expanded(child: Text(note.title, maxLines: 1, overflow: TextOverflow.ellipsis, style: textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold))),
                  if (note.isPinned) ...[const SizedBox(width: 8), Icon(Icons.push_pin, size: 16, color: theme.colorScheme.tertiary)]
                ],
              ),
              const SizedBox(height: 6),
              if (previewContent.isNotEmpty)
                Text(previewContent, maxLines: 2, overflow: TextOverflow.ellipsis, style: textTheme.bodyMedium?.copyWith(color: theme.colorScheme.onSurfaceVariant)),
              SizedBox(height: previewContent.isNotEmpty ? 8 : 0),
              Row(
                children: [
                  if(note.attachments.isNotEmpty) ...[Icon(Icons.attach_file, size: 14, color: theme.colorScheme.outline), const SizedBox(width: 4), Text(note.attachments.length.toString(), style: textTheme.bodySmall?.copyWith(color: theme.colorScheme.outline))],
                  if(note.linkedTaskIds?.isNotEmpty ?? false) ...[const SizedBox(width: 8), Icon(Icons.link, size: 14, color: theme.colorScheme.outline), const SizedBox(width: 4), Text(note.linkedTaskIds!.length.toString(), style: textTheme.bodySmall?.copyWith(color: theme.colorScheme.outline))],
                  const Spacer(),
                  Text(formatRelativeDate(note.lastModifiedTimestamp, isNote: true), style: textTheme.bodySmall?.copyWith(color: theme.colorScheme.outline)),
                ],
              )
            ],
          ),
        ),
      ),
    );
  }
}

// --- /lib/src/features/notes/presentation/edit_note_screen.dart ---
class EditNoteScreen extends StatefulWidget {
  final String? noteId;
  const EditNoteScreen({super.key, this.noteId});
  @override State<EditNoteScreen> createState() => _EditNoteScreenState();
}

class _EditNoteScreenState extends State<EditNoteScreen> {
  final _titleController = TextEditingController();
  final _contentController = TextEditingController();
  final _contentFocusNode = FocusNode();
  final _scrollController = ScrollController();

  String? _currentNoteId;
  Note? _currentNote;
  bool _isNewNote = true;
  bool _isLoading = true;
  bool _hasUnsavedChanges = false;
  Timer? _autoSaveTimer;
  List<String> _categories = []; // State for categories

  final AppLogger _logger = AppLogger();

  @override
  void initState() {
    super.initState();
    _currentNoteId = widget.noteId;
    _isNewNote = _currentNoteId == null;
    _initializeNote();
    _titleController.addListener(_onChanged);
    _contentController.addListener(_onChanged);
  }

  @override
  void dispose() {
    _autoSaveTimer?.cancel();
    _saveNote(isFinal: true);
    _titleController.dispose();
    _contentController.dispose();
    _contentFocusNode.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  void _onChanged() {
    if (_isLoading) return;
    if (!_hasUnsavedChanges) {
      setState(() { _hasUnsavedChanges = true; });
    }
    _resetAutoSaveTimer();
  }

  void _resetAutoSaveTimer() {
    _autoSaveTimer?.cancel();
    _autoSaveTimer = Timer(const Duration(seconds: 3), () => _saveNote());
  }

  Future<void> _initializeNote() async {
    final noteManager = context.read<NoteManager>();
    if (_isNewNote) {
      try {
        final newId = await noteManager.createNewNote();
        if(!mounted) return;
        _currentNote = noteManager.getNoteById(newId);
        _currentNoteId = newId;
        _isNewNote = false;
        _setupState();
        setState(() { _isLoading = false; });
        WidgetsBinding.instance.addPostFrameCallback((_) { FocusScope.of(context).requestFocus(_contentFocusNode); });
      } catch (e) {
        _logger.log("Error creating new note: $e");
        if(mounted) Navigator.pop(context);
      }
    } else {
      _currentNote = noteManager.getNoteById(_currentNoteId!);
      _setupState();
      setState(() { _isLoading = false; });
    }
  }

  void _setupState() {
    if (_currentNote == null) return;
    _titleController.text = _currentNote!.title;
    _contentController.text = _currentNote!.content;
    _categories = List<String>.from(_currentNote!.categories ?? []); // Initialize categories
  }

  Future<void> _saveNote({bool isFinal = false}) async {
    if (!_hasUnsavedChanges || _currentNoteId == null || _currentNote == null) return;

    _autoSaveTimer?.cancel();

    String title = _titleController.text.trim();
    if (title.isEmpty) title = "Untitled Note";

    final updatedNote = _currentNote!.copyWith(
      title: title,
      content: _contentController.text,
      lastModifiedTimestamp: DateTime.now(),
      categories: _categories, // Save categories
    );
    await context.read<NoteManager>().updateNote(updatedNote);

    if (mounted && !isFinal) {
      setState(() {
        _hasUnsavedChanges = false;
        _currentNote = updatedNote;
      });
    }
  }

  Future<void> _deleteNote() async {
    if (_currentNoteId == null) return;
    final confirm = await showDialog<bool>(context: context, builder: (ctx) => AlertDialog(title: const Text('Delete Note'), content: const Text('Are you sure you want to permanently delete this note?'), actions: [ TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('Cancel')), TextButton(onPressed: () => Navigator.of(ctx).pop(true), style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.error), child: const Text('Delete'))]));
    if (confirm == true && mounted) { _hasUnsavedChanges = false; _autoSaveTimer?.cancel(); await context.read<NoteManager>().deleteNote(_currentNoteId!); if (mounted) Navigator.pop(context); }
  }

  void _togglePin() {
    if (_currentNote == null) return;
    final isCurrentlyPinned = _currentNote!.isPinned;
    final updatedNote = _currentNote!.copyWith(isPinned: !isCurrentlyPinned);
    setState(() => _currentNote = updatedNote);
    _onChanged();
    HapticFeedback.mediumImpact();
    ScaffoldMessenger.of(context)..hideCurrentSnackBar()..showSnackBar(SnackBar(
      content: Text(isCurrentlyPinned ? "Note unpinned" : "Note pinned to top"),
      duration: const Duration(seconds: 2),
    ));
  }

  void _linkTask() {
    showDialog(
      context: context,
      builder: (ctx) => LinkTaskDialog(
        noteId: _currentNoteId!,
        alreadyLinkedTaskIds: _currentNote?.linkedTaskIds ?? [],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    if (widget.noteId != null) {
      _currentNote = context.watch<NoteManager>().getNoteById(widget.noteId!);
    }
    final taskManager = context.watch<TaskManager>();

    return WillPopScope(
      onWillPop: () async {
        _saveNote(isFinal: true);
        return true;
      },
      child: Scaffold(
        appBar: AppBar(
          title: Text(_isNewNote ? "New Note" : "Edit Note"),
          actions: _isLoading ? [] : [
            if (_hasUnsavedChanges) const Padding(padding: EdgeInsets.only(right: 12.0), child: SizedBox(height: 20, width: 20, child: CircularProgressIndicator(strokeWidth: 2.5))),
            IconButton(icon: Icon((_currentNote?.isPinned ?? false) ? Icons.push_pin : Icons.push_pin_outlined), tooltip: "Pin Note", onPressed: _togglePin),
            IconButton(icon: const Icon(Icons.link_rounded), tooltip: "Link Task", onPressed: _linkTask),
            IconButton(icon: const Icon(Icons.delete_outline), tooltip: "Delete Note", onPressed: _deleteNote),
          ],
        ),
        body: _isLoading
            ? const Center(child: CircularProgressIndicator())
            : SafeArea(
          top: false,
          bottom: false,
          child: Column(
            children: [
              Expanded(
                child: CustomScrollView(
                  slivers: [
                    SliverToBoxAdapter(
                      child: Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 16.0),
                        child: TextFormField(
                          controller: _titleController,
                          style: Theme.of(context).textTheme.headlineSmall,
                          decoration: const InputDecoration(border: InputBorder.none, hintText: "Title"),
                          textCapitalization: TextCapitalization.sentences,
                          maxLines: 1,
                        ),
                      ),
                    ),
                    SliverToBoxAdapter(
                      child: Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
                        child: CategoryInput(
                          selectedCategories: _categories,
                          onChanged: (newCategories) {
                            setState(() {
                              _categories = newCategories;
                            });
                            _onChanged();
                          },
                        ),
                      ),
                    ),
                    const SliverToBoxAdapter(child: Divider(height: 1)),
                    SliverFillRemaining(
                      hasScrollBody: true,
                      child: Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 16.0),
                        child: TextFormField(
                          controller: _contentController,
                          focusNode: _contentFocusNode,
                          scrollController: _scrollController,
                          decoration: const InputDecoration(
                            border: InputBorder.none,
                            hintText: "Start writing your note...",
                          ),
                          textCapitalization: TextCapitalization.sentences,
                          keyboardType: TextInputType.multiline,
                          maxLines: null,
                          expands: true,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              if(_currentNote?.linkedTaskIds?.isNotEmpty ?? false)
                _buildLinkedTasksView(taskManager),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildLinkedTasksView(TaskManager taskManager) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Divider(),
        Padding(
          padding: const EdgeInsets.fromLTRB(16, 8, 16, 8),
          child: Text("LINKED TASKS", style: Theme.of(context).textTheme.labelSmall?.copyWith(color: Theme.of(context).colorScheme.primary, fontWeight: FontWeight.bold)),
        ),
        SizedBox(
          width: double.infinity,
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Wrap(
              spacing: 8, runSpacing: 8,
              children: _currentNote!.linkedTaskIds!.map((taskId) {
                final task = taskManager.originalTasks.firstWhere((t) => t.id == taskId, orElse: () => Task(id: taskId, userId: '', title: 'Loading...', creationTimestamp: DateTime.now()));
                return InkWell(
                  onTap: () => Navigator.pushNamed(context, Constants.taskDetailRoute, arguments: taskId),
                  child: Chip(
                    avatar: const Icon(Icons.task_alt_outlined, size: 18),
                    label: Text(task.title),
                    onDeleted: () async {
                      await context.read<FirestoreService>().unlinkTaskAndNote(taskId, _currentNoteId!);
                      setState(() { _onChanged(); });
                    },
                    deleteIconColor: Theme.of(context).colorScheme.onSurfaceVariant.withOpacity(0.7),
                    deleteButtonTooltipMessage: "Unlink Task",
                    visualDensity: VisualDensity.compact,
                  ),
                );
              }).toList(),
            ),
          ),
        ),
        const SizedBox(height: 12),
      ],
    );
  }
}

// --- /lib/src/features/calendar/calendar_view.dart ---
class CalendarView extends StatefulWidget {
  const CalendarView({super.key});
  @override State<CalendarView> createState() => _CalendarViewState();
}
class _CalendarViewState extends State<CalendarView> {
  DateTime _focusedDay = DateTime.now();
  DateTime? _selectedDay;
  late final ValueNotifier<List<Task>> _selectedTasks;
  CalendarFormat _calendarFormat = CalendarFormat.month;

  @override
  void initState() {
    super.initState();
    _selectedDay = _focusedDay;
    _selectedTasks = ValueNotifier(_getTasksForDay(_selectedDay!));
  }

  @override
  void dispose() {
    _selectedTasks.dispose();
    super.dispose();
  }

  List<Task> _getTasksForDay(DateTime day) {
    final taskManager = context.read<TaskManager>();
    return taskManager.originalTasks.where((task) => task.dueDate != null && isSameDay(task.dueDate, day)).toList();
  }

  void _onDaySelected(DateTime selectedDay, DateTime focusedDay) {
    if (!isSameDay(_selectedDay, selectedDay)) {
      HapticFeedback.lightImpact();
      setState(() {
        _selectedDay = selectedDay;
        _focusedDay = focusedDay;
      });
      _selectedTasks.value = _getTasksForDay(selectedDay);
    }
  }

  @override
  Widget build(BuildContext context) {
    final taskManager = context.watch<TaskManager>();
    if (taskManager.isLoading) return const Center(child: CircularProgressIndicator());

    return OrientationBuilder(
      builder: (context, orientation) {
        final isLandscape = orientation == Orientation.landscape;
        final currentFormat = isLandscape ? CalendarFormat.week : _calendarFormat;

        if (isLandscape) {
          return Row(
            children: [
              Expanded(
                flex: 3,
                child: Column(
                  children: [
                    Padding(
                      padding: const EdgeInsets.all(12.0),
                      child: Text(
                        _selectedDay != null ? DateFormat.yMMMMd().format(_selectedDay!) : "Select a day",
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                    ),
                    const Divider(),
                    Expanded(child: _buildTaskList()),
                  ],
                ),
              ),
              const VerticalDivider(width: 1, thickness: 1),
              Expanded(
                flex: 4,
                child: _buildCalendar(currentFormat, true),
              ),
            ],
          );
        } else {
          return Column(
            children: [
              _buildCalendar(currentFormat, false),
              const Divider(),
              Expanded(
                child: _buildTaskList(),
              ),
            ],
          );
        }
      },
    );
  }

  Widget _buildCalendar(CalendarFormat format, bool isLandscape) {
    final theme = Theme.of(context);
    return TableCalendar<Task>(
      firstDay: DateTime.utc(2020, 1, 1),
      lastDay: DateTime.utc(2030, 12, 31),
      focusedDay: _focusedDay,
      selectedDayPredicate: (day) => isSameDay(_selectedDay, day),
      onDaySelected: _onDaySelected,
      eventLoader: _getTasksForDay,
      calendarFormat: format,
      onFormatChanged: (newFormat) {
        if (!isLandscape && _calendarFormat != newFormat) {
          setState(() { _calendarFormat = newFormat; });
        }
      },
      calendarStyle: CalendarStyle(
        todayDecoration: BoxDecoration(color: theme.colorScheme.primary.withOpacity(0.5), shape: BoxShape.circle),
        selectedDecoration: BoxDecoration(color: theme.colorScheme.primary, shape: BoxShape.circle),
      ),
      headerStyle: HeaderStyle(
        formatButtonVisible: !isLandscape,
        titleCentered: true,
        titleTextStyle: theme.textTheme.titleLarge!,
      ),
      onPageChanged: (focusedDay) {
        setState(() {
          _focusedDay = focusedDay;
        });
      },
      calendarBuilders: CalendarBuilders(
        markerBuilder: (context, day, events) {
          if (events.isNotEmpty) {
            return Positioned(
              right: 1,
              bottom: 1,
              child: Container(
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: events.any((task) => !task.isComplete)
                      ? theme.colorScheme.tertiary
                      : Colors.green.withOpacity(0.7),
                ),
                width: 16.0,
                height: 16.0,
                child: Center(
                  child: Text(
                    '${events.length}',
                    style: TextStyle(
                        color: events.any((task) => !task.isComplete) ? Colors.black : Colors.white,
                        fontSize: 10.0, fontWeight: FontWeight.bold),
                  ),
                ),
              ),
            );
          }
          return null;
        },
      ),
    );
  }

  Widget _buildTaskList() {
    return ValueListenableBuilder<List<Task>>(
      valueListenable: _selectedTasks,
      builder: (context, value, _) {
        if (value.isEmpty) {
          return Center(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Text(
                _selectedDay == null ? "Select a day to see tasks" : "No tasks scheduled for this day.",
                style: TextStyle(color: Colors.grey.shade600),
                textAlign: TextAlign.center,
              ),
            ),
          );
        }
        return ListView.builder(
          padding: const EdgeInsets.only(bottom: 80),
          itemCount: value.length,
          itemBuilder: (context, index) {
            final task = value[index];
            return TaskListItem(task: task, onTap: () => Navigator.pushNamed(context, Constants.taskDetailRoute, arguments: task.id), onLongPress: (){});
          },
        );
      },
    );
  }
}

// --- /lib/src/common_widgets/attachment_chip.dart ---
class AttachmentChip extends StatelessWidget {
  final Attachment attachment;
  final VoidCallback? onDelete;
  final VoidCallback? onPressed;

  const AttachmentChip({super.key, required this.attachment, this.onDelete, this.onPressed});

  IconData _getIconForType(AttachmentType type) {
    switch (type) {
      case AttachmentType.image: return Icons.image_outlined;
      case AttachmentType.pdf: return Icons.picture_as_pdf_outlined;
      case AttachmentType.audio: return Icons.audiotrack_outlined;
      default: return Icons.insert_drive_file_outlined;
    }
  }

  @override
  Widget build(BuildContext context) {
    return InputChip(
      avatar: Icon(_getIconForType(attachment.type), size: 18),
      label: Text(attachment.fileName, overflow: TextOverflow.ellipsis),
      onPressed: onPressed,
      onDeleted: onDelete,
      deleteButtonTooltipMessage: "Remove Attachment",
    );
  }
}

// --- /lib/src/common_widgets/recurrence_dialog.dart ---
class RecurrenceDialog extends StatefulWidget {
  final RecurrenceRule? initialRule;
  final Function(RecurrenceRule?) onSave;
  const RecurrenceDialog({super.key, this.initialRule, required this.onSave});
  @override State<RecurrenceDialog> createState() => _RecurrenceDialogState();
}

class _RecurrenceDialogState extends State<RecurrenceDialog> {
  RecurrenceFrequency _frequency = RecurrenceFrequency.daily;
  int _interval = 1;

  @override
  void initState() {
    super.initState();
    if(widget.initialRule != null) {
      _frequency = widget.initialRule!.frequency;
      _interval = widget.initialRule!.interval;
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text("Set Recurrence"),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          DropdownButtonFormField<RecurrenceFrequency>(
            value: _frequency,
            items: RecurrenceFrequency.values.map((f) => DropdownMenuItem(value: f, child: Text(f.name[0].toUpperCase() + f.name.substring(1)))).toList(),
            onChanged: (val) { if(val != null) setState(()=>_frequency = val); },
            decoration: const InputDecoration(labelText: "Frequency"),
          ),
          const SizedBox(height: 20),
          TextFormField(
            initialValue: _interval.toString(),
            keyboardType: TextInputType.number,
            inputFormatters: [FilteringTextInputFormatter.digitsOnly],
            decoration: InputDecoration(labelText: "Repeat every", suffixText: "${_frequency.name}s"),
            onChanged: (val) => setState(()=> _interval = int.tryParse(val) ?? 1),
          )
        ],
      ),
      actions: [
        TextButton(onPressed: ()=>Navigator.of(context).pop(), child: const Text("Cancel")),
        ElevatedButton(onPressed: (){
          widget.onSave(RecurrenceRule(frequency: _frequency, interval: max(1, _interval)));
          Navigator.of(context).pop();
        }, child: const Text("Save")),
      ],
    );
  }
}

// --- /lib/src/features/account/presentation/change_username_screen.dart ---
class ChangeUsernameScreen extends StatefulWidget {
  const ChangeUsernameScreen({super.key});

  @override
  State<ChangeUsernameScreen> createState() => _ChangeUsernameScreenState();
}

class _ChangeUsernameScreenState extends State<ChangeUsernameScreen> {
  final _formKey = GlobalKey<FormState>();
  final _controller = TextEditingController();
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    final authService = context.read<AuthService>();
    _controller.text = authService.currentUser?.displayName ?? '';
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  Future<void> _updateUsername() async {
    FocusScope.of(context).unfocus();
    if (!_formKey.currentState!.validate()) {
      return;
    }

    if (_controller.text.trim() == context.read<AuthService>().currentUser?.displayName) {
      Navigator.of(context).pop();
      return;
    }

    setState(() => _isLoading = true);
    final authService = context.read<AuthService>();

    try {
      await authService.updateUsername(_controller.text.trim());
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Username updated successfully!'),
            backgroundColor: Colors.green,
          ),
        );
        Navigator.of(context).pop();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to update username: $e'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        // CORRECTED: Wrapped the assignment in curly braces {}.
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Change Username")),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.edit_note,
                  size: 60,
                  color: Theme.of(context).colorScheme.primary,
                ),
                const SizedBox(height: 20),
                Text(
                  'What should we call you?',
                  style: Theme.of(context).textTheme.headlineSmall,
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 8),
                Text(
                  'This name will be displayed in the app greeting.',
                  style: Theme.of(context).textTheme.bodyMedium,
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 30),
                TaskFormField(
                  controller: _controller,
                  labelText: 'New Username',
                  prefixIcon: const Icon(Icons.person_outline),
                  autofocus: true,
                  validator: (v) {
                    if (v == null || v.trim().isEmpty) {
                      return 'Username cannot be empty.';
                    }
                    if (v.trim().length < 3) {
                      return 'Must be at least 3 characters long.';
                    }
                    if (v.contains(' ')) return 'No spaces allowed';
                    return null;
                  },
                  onFieldSubmitted: (_) => _updateUsername(),
                  textInputAction: TextInputAction.done,
                ),
                const SizedBox(height: 40),
                ElevatedButton(
                  onPressed: _isLoading ? null : _updateUsername,
                  child: _isLoading
                      ? const SizedBox(
                    height: 24,
                    width: 24,
                    child: CircularProgressIndicator(strokeWidth: 3),
                  )
                      : const Text("Save Username"),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

// --- /lib/src/features/auth/presentation/change_password_screen.dart ---
class ChangePasswordScreen extends StatefulWidget {
  const ChangePasswordScreen({super.key});

  @override
  State<ChangePasswordScreen> createState() => _ChangePasswordScreenState();
}

class _ChangePasswordScreenState extends State<ChangePasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _currentPasswordController = TextEditingController();
  final _newPasswordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _isLoading = false;

  @override
  void dispose() {
    _currentPasswordController.dispose();
    _newPasswordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _changePassword() async {
    FocusScope.of(context).unfocus();
    if (!_formKey.currentState!.validate()) {
      return;
    }

    setState(() => _isLoading = true);

    final authService = context.read<AuthService>();
    try {
      await authService.changePassword(
        currentPassword: _currentPasswordController.text,
        newPassword: _newPasswordController.text,
      );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Password changed successfully!'),
            backgroundColor: Colors.green,
          ),
        );
        Navigator.of(context).pop();
      }
    } on fb_auth.FirebaseAuthException catch (e) {
      if (mounted) {
        String errorMessage = "An error occurred.";
        if (e.code == 'wrong-password') {
          errorMessage = "The current password you entered is incorrect.";
        } else if (e.code == 'weak-password') {
          errorMessage = "The new password is too weak.";
        } else if (e.code == 'requires-recent-login') {
          errorMessage = "This action is sensitive and requires recent authentication. Please sign out and sign back in before trying again.";
        }
        else {
          errorMessage = e.message ?? errorMessage;
        }
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(errorMessage),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('An unexpected error occurred: ${e.toString()}'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Change Password')),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                PasswordFormField(
                  controller: _currentPasswordController,
                  labelText: 'Current Password',
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your current password.';
                    }
                    return null;
                  },
                  textInputAction: TextInputAction.next,
                ),
                const SizedBox(height: 20),
                PasswordFormField(
                  controller: _newPasswordController,
                  labelText: 'New Password',
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter a new password.';
                    }
                    if (value.length < 6) {
                      return 'Password must be at least 6 characters long.';
                    }
                    return null;
                  },
                  textInputAction: TextInputAction.next,
                ),
                const SizedBox(height: 20),
                PasswordFormField(
                  controller: _confirmPasswordController,
                  labelText: 'Confirm New Password',
                  validator: (value) {
                    if (value != _newPasswordController.text) {
                      return 'Passwords do not match.';
                    }
                    return null;
                  },
                  textInputAction: TextInputAction.done,
                  onFieldSubmitted: (_) => _changePassword(),
                ),
                const SizedBox(height: 40),
                ElevatedButton(
                  onPressed: _isLoading ? null : _changePassword,
                  child: _isLoading
                      ? const SizedBox(
                    width: 24,
                    height: 24,
                    child: CircularProgressIndicator(strokeWidth: 3),
                  )
                      : const Text('Update Password'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

// --- /lib/src/features/account/presentation/account_screen.dart ---
class AccountScreen extends StatelessWidget {
  const AccountScreen({super.key});

  Future<void> _confirmSignOut(BuildContext context, AuthService authService) async {
    final confirm = await showDialog<bool>(context: context, builder: (ctx) => AlertDialog(title: const Text('Confirm Sign Out'), content: const Text('Are you sure you want to sign out?'), actions: [TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('Cancel')), TextButton(onPressed: () => Navigator.of(ctx).pop(true), style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.error), child: const Text('Sign Out'))]));
    if (confirm == true && context.mounted) {
      await authService.signOut();
      Navigator.of(context).pushNamedAndRemoveUntil(Constants.authWrapperRoute, (route) => false);
    }
  }
  Future<void> _confirmDeleteAccount(BuildContext context, AuthService authService) async {
    final confirm = await showDialog<bool>(context: context, builder: (ctx) => AlertDialog(title: const Text('Delete Account'), content: const Text('This will permanently delete your account and all associated data. This action cannot be undone.'), actions: [TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('Cancel')), TextButton(onPressed: () => Navigator.of(ctx).pop(true), style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.error), child: const Text('Delete Account', style: TextStyle(fontWeight: FontWeight.bold)))]));
    if (confirm == true && context.mounted) {
      try {
        await authService.deleteAccount();
        if (context.mounted) {
          Navigator.of(context).pushNamedAndRemoveUntil(Constants.authWrapperRoute, (route) => false);
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Account deleted successfully.'), backgroundColor: Colors.redAccent));
        }
      } on Exception catch (e) { if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(e.toString()), backgroundColor: Theme.of(context).colorScheme.error)); }
    }
  }

  @override
  Widget build(BuildContext context) {
    final authService = context.read<AuthService>();
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        title: const Text("My Account"),
      ),
      body: StreamBuilder<fb_auth.User?>(
          stream: authService.authStateChanges,
          builder: (context, snapshot) {
            final user = snapshot.data;
            if (user == null) {
              return const Center(child: Text("Not signed in."));
            }

            final displayName = user.displayName ?? "No Username";
            final userInitial = displayName.isNotEmpty ? displayName[0].toUpperCase() : "?";

            return ListView(
              children: [
                Padding(
                  padding: const EdgeInsets.symmetric(vertical: 24.0),
                  child: Column(
                    children: [
                      CircleAvatar(
                        radius: 40,
                        backgroundColor: theme.colorScheme.primaryContainer,
                        child: Text(userInitial, style: theme.textTheme.headlineMedium?.copyWith(color: theme.colorScheme.onPrimaryContainer)),
                      ),
                      const SizedBox(height: 12),
                      Text(displayName, style: theme.textTheme.titleLarge),
                      const SizedBox(height: 4),
                      Text(user.email ?? "No Email", style: theme.textTheme.bodyMedium?.copyWith(color: theme.colorScheme.outline)),
                    ],
                  ),
                ),
                _buildSectionHeader(context, "Profile Settings"),
                ListTile(
                  leading: const Icon(Icons.person_outline),
                  title: const Text('Change Username'),
                  onTap: () => Navigator.pushNamed(context, Constants.changeUsernameRoute),
                ),
                _buildSectionHeader(context, "Security"),
                ListTile(
                  leading: const Icon(Icons.lock_outline),
                  title: const Text('Change Password'),
                  onTap: () => Navigator.pushNamed(context, Constants.changePasswordRoute),
                ),
                const Divider(height: 32),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: OutlinedButton.icon(
                      icon: const Icon(Icons.logout),
                      label: const Text('Sign Out'),
                      onPressed: () => _confirmSignOut(context, authService)
                  ),
                ),
                const SizedBox(height: 12),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: OutlinedButton.icon(
                      style: OutlinedButton.styleFrom(foregroundColor: theme.colorScheme.error, side: BorderSide(color: theme.colorScheme.error)),
                      icon: const Icon(Icons.delete_forever_outlined),
                      label: const Text('Delete Account'),
                      onPressed: () => _confirmDeleteAccount(context, authService)
                  ),
                ),
                const SizedBox(height: 24),
              ],
            );
          }
      ),
    );
  }

  Padding _buildSectionHeader(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
      child: Text(title.toUpperCase(), style: Theme.of(context).textTheme.labelSmall?.copyWith(color: Theme.of(context).colorScheme.primary, fontWeight: FontWeight.bold)),
    );
  }
}

// --- /lib/src/features/focus/presentation/focus_screen.dart ---
class FocusScreen extends StatefulWidget {
  const FocusScreen({super.key});

  @override
  State<FocusScreen> createState() => _FocusScreenState();
}

class _FocusScreenState extends State<FocusScreen> with SingleTickerProviderStateMixin {
  late final TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("Focus Hub"),
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(icon: Icon(Icons.timer_outlined), text: "Stopwatch"),
            Tab(icon: Icon(Icons.hourglass_bottom_rounded), text: "Timer"),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: const [
          StopwatchTab(),
          CountdownTimerTab(),
        ],
      ),
    );
  }
}

class StopwatchTab extends StatefulWidget {
  const StopwatchTab({super.key});

  @override
  State<StopwatchTab> createState() => _StopwatchTabState();
}

class _StopwatchTabState extends State<StopwatchTab> with AutomaticKeepAliveClientMixin {
  final Stopwatch _stopwatch = Stopwatch();
  Timer? _timer;
  String _displayTime = "00:00.00";
  final List<String> _laps = [];
  late NotificationService _notificationService;

  @override
  bool get wantKeepAlive => true;

  @override
  void initState() {
    super.initState();
    _notificationService = context.read<NotificationService>();
  }

  @override
  void dispose() {
    _timer?.cancel();
    _stopwatch.stop();
    _notificationService.cancelOngoingFocusNotification();
    super.dispose();
  }

  void _startStop() {
    HapticFeedback.lightImpact();
    setState(() {
      if (_stopwatch.isRunning) {
        _stopwatch.stop();
        _timer?.cancel();
        _notificationService.cancelOngoingFocusNotification();
      } else {
        _stopwatch.start();
        _timer = Timer.periodic(const Duration(milliseconds: 30), (timer) {
          if (_stopwatch.isRunning) {
            if (mounted) {
              setState(() {
                _displayTime = _formatStopwatchTime(_stopwatch.elapsed);
              });
              if (_stopwatch.elapsed.inMilliseconds % 1000 < 30) {
                _notificationService.showOngoingFocusNotification(
                    "Stopwatch Running", "Elapsed: $_displayTime");
              }
            }
          } else {
            timer.cancel();
          }
        });
      }
    });
  }

  void _reset() {
    HapticFeedback.mediumImpact();
    _timer?.cancel();
    _stopwatch.stop();
    _stopwatch.reset();
    _notificationService.cancelOngoingFocusNotification();
    setState(() {
      _displayTime = "00:00.00";
      _laps.clear();
    });
  }

  void _lap() {
    if (!_stopwatch.isRunning) return;
    HapticFeedback.lightImpact();
    final totalElapsed = _stopwatch.elapsed;
    setState(() {
      _laps.insert(
          0,
          "Lap ${_laps.length + 1}:  ${_formatStopwatchTime(totalElapsed)}");
    });
  }

  String _formatStopwatchTime(Duration d) {
    final minutes = d.inMinutes.remainder(60).toString().padLeft(2, '0');
    final seconds = d.inSeconds.remainder(60).toString().padLeft(2, '0');
    final centiseconds = (d.inMilliseconds.remainder(1000) ~/ 10).toString().padLeft(2, '0');
    return "$minutes:$seconds.$centiseconds";
  }

  @override
  Widget build(BuildContext context) {
    super.build(context);
    return OrientationBuilder(
      builder: (context, orientation) {
        if (orientation == Orientation.landscape) {
          return _buildLandscapeLayout();
        } else {
          return _buildPortraitLayout();
        }
      },
    );
  }

  Widget _buildPortraitLayout() {
    final theme = Theme.of(context);
    final isRunning = _stopwatch.isRunning;

    return Column(
      children: [
        const Spacer(flex: 2),
        Text(
          _displayTime,
          style: theme.textTheme.displayLarge?.copyWith(
              fontFamily: 'monospace',
              fontWeight: FontWeight.w300,
              fontSize: 60
          ),
        ),
        const Spacer(flex: 1),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            _buildControlButton(
                icon: Icons.refresh,
                label: 'Reset',
                onPressed: _stopwatch.elapsed > Duration.zero ? _reset : null),
            _buildControlButton(
              icon: isRunning ? Icons.pause : Icons.play_arrow,
              label: isRunning ? 'Pause' : 'Start',
              onPressed: _startStop,
              isPrimary: true,
            ),
            _buildControlButton(
                icon: Icons.flag_outlined,
                label: 'Lap',
                onPressed: isRunning ? _lap : null),
          ],
        ),
        const SizedBox(height: 24),
        const Divider(),
        Expanded(
          flex: 4,
          child: _buildLapsList(),
        ),
      ],
    );
  }

  Widget _buildLandscapeLayout() {
    final theme = Theme.of(context);
    final isRunning = _stopwatch.isRunning;

    return Row(
      children: [
        Expanded(
          flex: 4,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                _displayTime,
                style: theme.textTheme.displayLarge?.copyWith(
                    fontFamily: 'monospace',
                    fontWeight: FontWeight.w300,
                    fontSize: 52
                ),
              ),
              const SizedBox(height: 30),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  _buildControlButton(
                      icon: Icons.refresh,
                      label: 'Reset',
                      onPressed: _stopwatch.elapsed > Duration.zero ? _reset : null),
                  _buildControlButton(
                    icon: isRunning ? Icons.pause : Icons.play_arrow,
                    label: isRunning ? 'Pause' : 'Start',
                    onPressed: _startStop,
                    isPrimary: true,
                  ),
                  _buildControlButton(
                      icon: Icons.flag_outlined,
                      label: 'Lap',
                      onPressed: isRunning ? _lap : null),
                ],
              ),
            ],
          ),
        ),
        const VerticalDivider(width: 1),
        Expanded(
          flex: 3,
          child: _buildLapsList(),
        ),
      ],
    );
  }

  Widget _buildLapsList() {
    final theme = Theme.of(context);
    if (_laps.isEmpty) {
      return Center(
          child: Text('Laps will appear here',
              style: TextStyle(color: theme.colorScheme.outline)));
    }
    return ListView.separated(
      itemCount: _laps.length,
      padding: const EdgeInsets.symmetric(vertical: 8),
      separatorBuilder: (_, __) => const Divider(height: 1, indent: 16, endIndent: 16),
      itemBuilder: (context, index) {
        return ListTile(
          dense: true,
          leading: Text("#${_laps.length - index}",
              style: TextStyle(color: theme.colorScheme.outline, fontSize: 16)),
          title: Text(_laps[index], style: theme.textTheme.bodyLarge?.copyWith(fontFamily: 'monospace')),
        );
      },
    );
  }

  Widget _buildControlButton(
      {required IconData icon,
        required String label,
        required VoidCallback? onPressed,
        bool isPrimary = false}) {
    final theme = Theme.of(context);
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        ElevatedButton(
          onPressed: onPressed,
          style: ElevatedButton.styleFrom(
            shape: const CircleBorder(),
            padding: EdgeInsets.all(isPrimary ? 22 : 18),
            backgroundColor: isPrimary ? theme.colorScheme.primary : theme.colorScheme.surfaceVariant,
            foregroundColor: isPrimary ? theme.colorScheme.onPrimary : theme.colorScheme.onSurfaceVariant,
            elevation: isPrimary ? 4 : 1,
          ),
          child: Icon(icon, size: isPrimary ? 30 : 26),
        ),
        const SizedBox(height: 8),
        Text(label, style: theme.textTheme.labelMedium?.copyWith(color: theme.colorScheme.onSurfaceVariant)),
      ],
    );
  }
}

enum TimerState { initial, running, paused, elapsed }

class CountdownTimerTab extends StatefulWidget {
  const CountdownTimerTab({super.key});

  @override
  State<CountdownTimerTab> createState() => _CountdownTimerTabState();
}

class _CountdownTimerTabState extends State<CountdownTimerTab> with AutomaticKeepAliveClientMixin {
  int _hours = 0;
  int _minutes = 25;
  int _seconds = 0;

  Timer? _countdownTimer;
  Duration _totalDuration = const Duration(minutes: 25);
  Duration _remaining = const Duration(minutes: 25);
  Duration _overtime = Duration.zero;
  TimerState _timerState = TimerState.initial;
  late NotificationService _notificationService;
  String? _linkedTaskId;
  Task? _linkedTask;


  @override
  bool get wantKeepAlive => true;

  @override
  void initState() {
    super.initState();
    _notificationService = context.read<NotificationService>();
  }

  @override
  void dispose() {
    _countdownTimer?.cancel();
    _notificationService.cancelOngoingFocusNotification();
    super.dispose();
  }

  Future<void> _handleTimerCompletion() async {
    HapticFeedback.vibrate();
    _notificationService.cancelOngoingFocusNotification();
    String notificationTitle = "Timer Complete!";
    String notificationBody = "Your focus session for ${_formatDuration(_totalDuration)} has finished.";

    if (_linkedTaskId != null && mounted) {
      final taskManager = context.read<TaskManager>();
      try {
        final taskToUpdate = taskManager.originalTasks.firstWhere((t) => t.id == _linkedTaskId);
        final updatedTask = taskToUpdate.copyWith(
          focusSessions: taskToUpdate.focusSessions + 1,
          totalFocusTime: taskToUpdate.totalFocusTime + _totalDuration.inMinutes,
        );
        await taskManager.updateTask(updatedTask);
        notificationBody = "Time added to task: '${updatedTask.title}'";
      } catch (e) {
        AppLogger().log("Error finding task to update for focus session: $e");
      }
    }

    _notificationService.showTimerCompletionNotification(notificationTitle, notificationBody);
  }


  void _startPauseTimer() {
    HapticFeedback.lightImpact();
    setState(() {
      if (_timerState == TimerState.running) {
        _countdownTimer?.cancel();
        _notificationService.showOngoingFocusNotification("Focus Timer Paused", "Remaining: ${_formatDuration(_remaining)}");
        _timerState = TimerState.paused;
      } else {
        if (_timerState == TimerState.initial) {
          _updateTotalDuration();
        }
        _timerState = TimerState.running;
        _countdownTimer = Timer.periodic(const Duration(seconds: 1), _tick);
      }
    });
  }

  void _tick(Timer timer) {
    if (!mounted) {
      timer.cancel();
      return;
    }

    if (_remaining.inSeconds > 0) {
      setState(() {
        _remaining -= const Duration(seconds: 1);
      });
      _notificationService.showOngoingFocusNotification("Focus Timer Active", "Remaining: ${_formatDuration(_remaining)}");
    } else {
      if (_timerState != TimerState.elapsed) {
        _handleTimerCompletion();
      }
      setState(() {
        _timerState = TimerState.elapsed;
        _overtime += const Duration(seconds: 1);
      });
      _notificationService.showOngoingFocusNotification("Timer Finished", "Overtime: ${_formatDuration(_overtime, isOvertime: true)}");
    }
  }

  void _resetTimer() {
    HapticFeedback.mediumImpact();
    _countdownTimer?.cancel();
    _notificationService.cancelOngoingFocusNotification();
    setState(() {
      _timerState = TimerState.initial;
      _hours = 0;
      _minutes = 25;
      _seconds = 0;
      _updateTotalDuration();
      _overtime = Duration.zero;
      _linkedTaskId = null;
      _linkedTask = null;
    });
  }

  void _updateTotalDuration() {
    if (_timerState == TimerState.running) return;
    final newDuration = Duration(hours: _hours, minutes: _minutes, seconds: _seconds);
    if (newDuration != _totalDuration) {
      setState(() {
        _totalDuration = newDuration;
        if (_timerState == TimerState.initial || _timerState == TimerState.paused) {
          _remaining = _totalDuration;
        }
      });
    }
  }

  String _formatDuration(Duration d, {bool isOvertime = false}) {
    String twoDigits(int n) => n.toString().padLeft(2, '0');
    final hours = twoDigits(d.inHours);
    final minutes = twoDigits(d.inMinutes.remainder(60));
    final seconds = twoDigits(d.inSeconds.remainder(60));
    final sign = isOvertime ? "+" : "";
    if (d.inHours > 0) {
      return "$sign$hours:$minutes:$seconds";
    }
    return "$sign$minutes:$seconds";
  }

  @override
  Widget build(BuildContext context) {
    super.build(context);
    return GestureDetector(
      onTap: () => FocusScope.of(context).unfocus(),
      child: OrientationBuilder(
        builder: (context, orientation) {
          if (orientation == Orientation.landscape) {
            return _buildLandscapeLayout();
          } else {
            return _buildPortraitLayout();
          }
        },
      ),
    );
  }

  Widget _buildPortraitLayout() {
    return Column(
      children: [
        Expanded(
          flex: 3,
          child: AnimatedSwitcher(
            duration: const Duration(milliseconds: 400),
            transitionBuilder: (child, animation) => FadeTransition(opacity: animation, child: child),
            child: (_timerState == TimerState.initial)
                ? _buildInitialDisplay()
                : _buildRunningDisplay(),
          ),
        ),
        if (_timerState == TimerState.initial) _buildLinkTaskButton(),
        Expanded(
          flex: 2,
          child: Center(
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: _getControlButtons(),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildLandscapeLayout() {
    return Row(
      children: [
        Expanded(
          flex: 5,
          child: AnimatedSwitcher(
            duration: const Duration(milliseconds: 400),
            transitionBuilder: (child, animation) => FadeTransition(opacity: animation, child: child),
            child: (_timerState == TimerState.initial)
                ? _buildInitialDisplay()
                : _buildRunningDisplay(isLandscape: true),
          ),
        ),
        const VerticalDivider(width: 1),
        Expanded(
          flex: 3,
          child: SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 16.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  if (_timerState == TimerState.initial) ...[
                    _buildLinkTaskButton(),
                    const SizedBox(height: 20),
                  ],
                  ..._getControlButtons(),
                ],
              ),
            ),
          ),
        )
      ],
    );
  }

  List<Widget> _getControlButtons() {
    return [
      _buildControlButton(
        icon: Icons.refresh,
        label: "Reset",
        onPressed: (_timerState != TimerState.initial) ? _resetTimer : null,
      ),
      _buildControlButton(
        icon: _timerState == TimerState.running ? Icons.pause_rounded : Icons.play_arrow_rounded,
        label: _timerState == TimerState.running ? "Pause" : "Start",
        onPressed: () {
          _updateTotalDuration();
          if (_totalDuration.inSeconds > 0) _startPauseTimer();
        },
        isPrimary: true,
      ),
    ];
  }

  Widget _buildControlButton(
      {required IconData icon,
        required String label,
        required VoidCallback? onPressed,
        bool isPrimary = false}) {
    final theme = Theme.of(context);
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        ElevatedButton(
          onPressed: onPressed,
          style: ElevatedButton.styleFrom(
            shape: const CircleBorder(),
            padding: EdgeInsets.all(isPrimary ? 24 : 20),
            backgroundColor: isPrimary ? theme.colorScheme.primary : theme.colorScheme.surfaceVariant,
            foregroundColor: isPrimary ? theme.colorScheme.onPrimary : theme.colorScheme.onSurfaceVariant,
            elevation: isPrimary ? 4 : 1,
          ),
          child: Icon(icon, size: isPrimary ? 32 : 28),
        ),
        const SizedBox(height: 8),
        Text(label, style: theme.textTheme.labelMedium?.copyWith(color: theme.colorScheme.onSurfaceVariant)),
      ],
    );
  }

  Widget _buildInitialDisplay() {
    final theme = Theme.of(context);
    final pickerTextStyle = theme.textTheme.headlineLarge?.copyWith(
      fontFamily: 'monospace',
      fontWeight: FontWeight.w300,
    );
    return LayoutBuilder(
        key: const ValueKey('initial'),
        builder: (context, constraints) {
          final itemExtent = (pickerTextStyle?.fontSize ?? 60) * 1.2;
          return Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                "Set Countdown Duration",
                style: theme.textTheme.titleMedium?.copyWith(color: theme.colorScheme.outline),
              ),
              const SizedBox(height: 20),
              SizedBox(
                height: itemExtent * 2.5,
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    _buildTimePicker(
                      context: context,
                      itemCount: 100,
                      initialItem: _hours,
                      onSelectedItemChanged: (value) => setState(() => _hours = value),
                      itemExtent: itemExtent,
                      textStyle: pickerTextStyle,
                    ),
                    Text('h', style: pickerTextStyle?.copyWith(color: theme.colorScheme.outline)),
                    const SizedBox(width: 12),
                    _buildTimePicker(
                      context: context,
                      itemCount: 60,
                      initialItem: _minutes,
                      onSelectedItemChanged: (value) => setState(() => _minutes = value),
                      itemExtent: itemExtent,
                      textStyle: pickerTextStyle,
                    ),
                    Text('m', style: pickerTextStyle?.copyWith(color: theme.colorScheme.outline)),
                    const SizedBox(width: 12),
                    _buildTimePicker(
                      context: context,
                      itemCount: 60,
                      initialItem: _seconds,
                      onSelectedItemChanged: (value) => setState(() => _seconds = value),
                      itemExtent: itemExtent,
                      textStyle: pickerTextStyle,
                    ),
                    Text('s', style: pickerTextStyle?.copyWith(color: theme.colorScheme.outline)),
                  ],
                ),
              ),
            ],
          );
        }
    );
  }

  Widget _buildTimePicker({
    required BuildContext context,
    required int itemCount,
    required int initialItem,
    required ValueChanged<int> onSelectedItemChanged,
    required double itemExtent,
    TextStyle? textStyle,
  }) {
    return SizedBox(
      width: 70,
      child: ListWheelScrollView.useDelegate(
        controller: FixedExtentScrollController(initialItem: initialItem),
        itemExtent: itemExtent,
        perspective: 0.005,
        physics: const FixedExtentScrollPhysics(),
        onSelectedItemChanged: onSelectedItemChanged,
        childDelegate: ListWheelChildBuilderDelegate(
          builder: (context, index) {
            return Center(
              child: Text(
                index.toString().padLeft(2, '0'),
                style: textStyle,
              ),
            );
          },
          childCount: itemCount,
        ),
      ),
    );
  }

  Widget _buildRunningDisplay({bool isLandscape = false}) {
    final theme = Theme.of(context);
    final isOvertime = _timerState == TimerState.elapsed;
    final isPaused = _timerState == TimerState.paused;
    final progress = _totalDuration.inSeconds > 0 ? _remaining.inSeconds / _totalDuration.inSeconds : 0.0;

    String statusText;
    Color statusColor;
    if (isOvertime) {
      statusText = "OVERTIME";
      statusColor = theme.colorScheme.error;
    } else if (isPaused) {
      statusText = "PAUSED";
      statusColor = theme.colorScheme.secondary;
    } else {
      statusText = "FOCUSING";
      statusColor = theme.colorScheme.primary;
    }

    Widget timerText = Text(
      isOvertime ? _formatDuration(_overtime, isOvertime: true) : _formatDuration(_remaining),
      style: (isLandscape ? theme.textTheme.displayMedium : theme.textTheme.displayLarge)
          ?.copyWith(
        fontFamily: 'monospace',
        fontWeight: FontWeight.w300,
        color: isOvertime ? theme.colorScheme.error : null,
      ),
      maxLines: 1,
      overflow: TextOverflow.ellipsis,
    );

    return Container(
      key: const ValueKey('running'),
      padding: const EdgeInsets.all(24.0),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          if (_linkedTask != null)
            Chip(
              avatar: const Icon(Icons.link),
              label: Text(_linkedTask!.title, overflow: TextOverflow.ellipsis),
              backgroundColor: statusColor.withOpacity(0.1),
            ),
          const SizedBox(height: 8),
          Text(
            statusText,
            style: theme.textTheme.titleMedium?.copyWith(
              color: statusColor,
              fontWeight: FontWeight.bold,
              letterSpacing: 2,
            ),
          ),
          const SizedBox(height: 12),
          if (isLandscape) Expanded(child: Center(child: timerText)) else timerText,
          const SizedBox(height: 24),
          SizedBox(
            width: double.infinity,
            child: LinearPercentIndicator(
              percent: isOvertime ? 1.0 : progress.clamp(0.0, 1.0),
              lineHeight: 12,
              barRadius: const Radius.circular(6),
              backgroundColor: theme.colorScheme.surfaceVariant,
              progressColor: statusColor,
              animateFromLastPercent: true,
              animation: true,
            ),
          ),
          const SizedBox(height: 12),
          Text(
            "${_formatDuration(_remaining)} / ${_formatDuration(_totalDuration)}",
            style: theme.textTheme.bodyMedium?.copyWith(color: theme.colorScheme.outline, fontFamily: 'monospace'),
          ),
        ],
      ),
    );
  }

  Widget _buildLinkTaskButton() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
      child: _linkedTask == null
          ? OutlinedButton.icon(
        icon: const Icon(Icons.add),
        label: const Text("Link to Task"),
        onPressed: _showLinkTaskDialog,
      )
          : InputChip(
        avatar: const Icon(Icons.link, color: Colors.green),
        label: Text(_linkedTask!.title, overflow: TextOverflow.ellipsis),
        onDeleted: () {
          setState(() {
            _linkedTaskId = null;
            _linkedTask = null;
          });
        },
        deleteButtonTooltipMessage: "Unlink Task",
      ),
    );
  }

  void _showLinkTaskDialog() {
    showDialog<String>(
      context: context,
      builder: (ctx) {
        final taskManager = context.read<TaskManager>();
        final availableTasks = taskManager.originalTasks.where((t) => !t.isComplete).toList();

        return AlertDialog(
          title: const Text("Link Session to Task"),
          content: SizedBox(
            width: double.maxFinite,
            child: availableTasks.isEmpty
                ? const Center(child: Text("No active tasks to link."))
                : ListView.builder(
              shrinkWrap: true,
              itemCount: availableTasks.length,
              itemBuilder: (context, index) {
                final task = availableTasks[index];
                return ListTile(
                  title: Text(task.title),
                  onTap: () => Navigator.of(context).pop(task.id),
                );
              },
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text("Cancel"),
            ),
          ],
        );
      },
    ).then((selectedTaskId) {
      if (selectedTaskId != null && mounted) {
        setState(() {
          _linkedTaskId = selectedTaskId;
          _linkedTask = context.read<TaskManager>().originalTasks.firstWhere((t) => t.id == selectedTaskId);
        });
      }
    });
  }
}

extension on TextEditingController {
  void selectAll() {
    if (text.isEmpty) return;
    selection = TextSelection(baseOffset: 0, extentOffset: text.length);
  }
}

// --- /lib/src/features/planning/presentation/planning_screen.dart ---
class PlanningScreen extends StatefulWidget {
  const PlanningScreen({super.key});

  @override
  State<PlanningScreen> createState() => _PlanningScreenState();
}

class _PlanningScreenState extends State<PlanningScreen> {
  List<String> _selectedTaskIds = [];
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    final taskManager = context.read<TaskManager>();
    _selectedTaskIds = taskManager.originalTasks
        .where((t) => t.isDailyPriority)
        .map((t) => t.id)
        .toList();
  }


  @override
  Widget build(BuildContext context) {
    final taskManager = context.watch<TaskManager>();
    final today = DateTime.now();

    final List<Task> availableTasks = taskManager.originalTasks.where((task) {
      if (task.isComplete) return false;
      bool isDue = task.dueDate != null && (task.dueDate!.isBefore(today) || isSameDay(task.dueDate, today));
      return isDue || task.isDailyPriority;
    }).toList();


    return Scaffold(
      appBar: AppBar(
        title: const Text("Plan Your Day"),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Text(
              "What are your Top 3 Priorities for Today?",
              style: Theme.of(context).textTheme.headlineSmall,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              "Select up to 3 tasks. These will be highlighted in your task list.",
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.outline),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),
            Expanded(
              child: availableTasks.isEmpty
                  ? Center(
                child: Text(
                  "No overdue or tasks for today!",
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(color: Colors.grey),
                ),
              )
                  : ListView.builder(
                itemCount: availableTasks.length,
                itemBuilder: (context, index) {
                  final task = availableTasks[index];
                  final isSelected = _selectedTaskIds.contains(task.id);
                  return Card(
                    color: isSelected ? Theme.of(context).colorScheme.primaryContainer.withOpacity(0.5) : null,
                    child: ListTile(
                      title: Text(task.title),
                      leading: Checkbox(
                        value: isSelected,
                        onChanged: (bool? value) {
                          setState(() {
                            if (value == true) {
                              if (_selectedTaskIds.length < 3) {
                                _selectedTaskIds.add(task.id);
                              } else {
                                ScaffoldMessenger.of(context).showSnackBar(
                                  const SnackBar(content: Text("You can only select up to 3 priorities.")),
                                );
                              }
                            } else {
                              _selectedTaskIds.remove(task.id);
                            }
                          });
                        },
                      ),
                      onTap: () {
                        setState(() {
                          if (isSelected) {
                            _selectedTaskIds.remove(task.id);
                          } else if (_selectedTaskIds.length < 3) {
                            _selectedTaskIds.add(task.id);
                          } else {
                            ScaffoldMessenger.of(context).showSnackBar(
                              const SnackBar(content: Text("You can only select up to 3 priorities.")),
                            );
                          }
                        });
                      },
                    ),
                  );
                },
              ),
            ),
            const SizedBox(height: 20),
            ElevatedButton.icon(
              onPressed: (_isLoading) ? null : () async {
                setState(() => _isLoading = true);
                await taskManager.setDailyPriorities(_selectedTaskIds);
                final prefs = await SharedPreferences.getInstance();
                await prefs.setString(Constants.lastPlanningDateKey, DateFormat('yyyy-MM-dd').format(DateTime.now()));
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Priorities set! Let's get to work.")));
                  Navigator.pop(context);
                }
              },
              icon: _isLoading ? const SizedBox.shrink() : const Icon(Icons.check_circle_outline),
              label: _isLoading ? const CircularProgressIndicator() : const Text("Confirm Priorities"),
            ),
          ],
        ),
      ),
    );
  }
}

// --- /lib/src/features/linking/presentation/link_note_dialog.dart ---
class LinkNoteDialog extends StatefulWidget {
  final String taskId;
  final List<String> alreadyLinkedNoteIds;

  const LinkNoteDialog({
    super.key,
    required this.taskId,
    required this.alreadyLinkedNoteIds,
  });

  @override
  State<LinkNoteDialog> createState() => _LinkNoteDialogState();
}

class _LinkNoteDialogState extends State<LinkNoteDialog> {
  String _searchQuery = '';

  @override
  Widget build(BuildContext context) {
    final noteManager = context.watch<NoteManager>();
    final firestoreService = context.read<FirestoreService>();
    final availableNotes = noteManager.originalNotes.where((note) {
      final isLinked = widget.alreadyLinkedNoteIds.contains(note.id);
      if (isLinked) return false;

      if (_searchQuery.isEmpty) return true;
      return note.title.toLowerCase().contains(_searchQuery.toLowerCase());
    }).toList();

    return AlertDialog(
      title: const Text("Link a Note"),
      content: SizedBox(
        width: double.maxFinite,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              onChanged: (value) => setState(() => _searchQuery = value),
              decoration: const InputDecoration(
                labelText: "Search notes",
                prefixIcon: Icon(Icons.search),
              ),
            ),
            const SizedBox(height: 16),
            Expanded(
              child: availableNotes.isEmpty
                  ? const Center(child: Text("No matching notes found."))
                  : ListView.builder(
                shrinkWrap: true,
                itemCount: availableNotes.length,
                itemBuilder: (context, index) {
                  final note = availableNotes[index];
                  return ListTile(
                    title: Text(note.title),
                    onTap: () async {
                      await firestoreService.linkTaskAndNote(widget.taskId, note.id);
                      if (mounted) {
                        Navigator.of(context).pop();
                        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Note linked successfully!")));
                      }
                    },
                  );
                },
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(onPressed: () => Navigator.of(context).pop(), child: const Text("Cancel")),
      ],
    );
  }
}

// --- /lib/src/features/linking/presentation/link_task_dialog.dart ---
class LinkTaskDialog extends StatefulWidget {
  final String noteId;
  final List<String> alreadyLinkedTaskIds;

  const LinkTaskDialog({
    super.key,
    required this.noteId,
    required this.alreadyLinkedTaskIds,
  });

  @override
  State<LinkTaskDialog> createState() => _LinkTaskDialogState();
}

class _LinkTaskDialogState extends State<LinkTaskDialog> {
  String _searchQuery = '';

  @override
  Widget build(BuildContext context) {
    final taskManager = context.watch<TaskManager>();
    final firestoreService = context.read<FirestoreService>();
    final availableTasks = taskManager.originalTasks.where((task) {
      final isLinked = widget.alreadyLinkedTaskIds.contains(task.id);
      if (isLinked) return false;

      if (_searchQuery.isEmpty) return true;
      return task.title.toLowerCase().contains(_searchQuery.toLowerCase());
    }).toList();

    return AlertDialog(
      title: const Text("Link a Task"),
      content: SizedBox(
        width: double.maxFinite,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              onChanged: (value) => setState(() => _searchQuery = value),
              decoration: const InputDecoration(
                labelText: "Search tasks",
                prefixIcon: Icon(Icons.search),
              ),
            ),
            const SizedBox(height: 16),
            Expanded(
              child: availableTasks.isEmpty
                  ? const Center(child: Text("No matching tasks found."))
                  : ListView.builder(
                shrinkWrap: true,
                itemCount: availableTasks.length,
                itemBuilder: (context, index) {
                  final task = availableTasks[index];
                  return ListTile(
                    title: Text(task.title),
                    onTap: () async {
                      await firestoreService.linkTaskAndNote(task.id, widget.noteId);
                      if (mounted) {
                        Navigator.of(context).pop();
                        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Task linked successfully!")));
                      }
                    },
                  );
                },
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(onPressed: () => Navigator.of(context).pop(), child: const Text("Cancel")),
      ],
    );
  }
}

// --- LEGAL & CREDITS SCREENS (UPDATED AND PROFESSIONAL) ---
class TermsScreen extends StatelessWidget {
  const TermsScreen({super.key});
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Terms of Service')),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Last Updated: July 15, 2025', style: Theme.of(context).textTheme.bodySmall?.copyWith(fontStyle: FontStyle.italic)),
            const SizedBox(height: 16),
            _buildSection(context, '1. Introduction and Acceptance of Terms', 'Welcome to NisanApp! These Terms of Service ("Terms") constitute a legally binding agreement between you ("User," "you," or "your") and Nisan Awa Tojah, in collaboration with Featuremind Nigeria Limited (collectively, "we," "us," or "our"). These Terms govern your access to and use of the NisanApp mobile application (the "App") and all related services.\n\nBy creating an account, accessing, or using the App, you acknowledge that you have read, understood, and agree to be bound by these Terms and our Privacy Policy. If you do not agree with these Terms, you must not access or use the App.'),
            _buildSection(context, '2. User Accounts and Security', 'To access the full functionality of the App, you must register for an account. You agree to provide information that is accurate, complete, and current at all times. Failure to do so constitutes a breach of the Terms, which may result in the immediate termination of your account.\n\nYou are solely responsible for safeguarding the password you use to access the App and for any activities or actions under your password. You agree to notify us immediately upon becoming aware of any breach of security or unauthorized use of your account.'),
            _buildSection(context, '3. User-Generated Content (UGC)', 'You are solely responsible for all the tasks, notes, attachments, and any other content you create, upload, or store within the App ("User Content"). You retain full ownership and all intellectual property rights to your User Content.\n\nBy using the App, you grant us a limited, worldwide, non-exclusive, royalty-free license to host, store, reproduce, and transmit your User Content solely for the purpose of operating, providing, and improving the App’s services to you. This license terminates when you delete your User Content or your account.'),
            _buildSection(context, '4. Intellectual Property Rights', 'Excluding your User Content, the App and its entire contents, features, and functionality—including but not limited to all source code, design, text, graphics, logos, and the "NisanApp" and "Featuremind Nigeria" names and logos—are the exclusive property of Nisan Awa Tojah and/or Featuremind Nigeria Limited, protected by copyright, trademark, and other intellectual property laws.\n\nYou are granted a limited, non-transferable, revocable license to use the App for your personal, non-commercial use. You agree not to copy, modify, create derivative works of, publicly display, or reverse-engineer any part of the App.'),
            _buildSection(context, '5. User Conduct and Responsibilities', 'You agree to use the App in a lawful manner and not to:\n\n• Upload or transmit any content that is unlawful, harmful, defamatory, or infringing on any third-party rights.\n• Engage in any activity that could disrupt, damage, or impair the performance or security of the App.\n• Attempt to gain unauthorized access to our systems, user accounts, or data.\n• Use the App for any commercial purpose without our express prior written consent.'),
            _buildSection(context, '6. Disclaimers and Limitation of Liability', 'THE APP IS PROVIDED ON AN "AS IS" AND "AS AVAILABLE" BASIS, WITHOUT ANY WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED. WE DO NOT GUARANTEE THAT THE APP WILL BE UNINTERRUPTED, SECURE, OR ERROR-FREE.\n\nTO THE FULLEST EXTENT PERMITTED BY LAW, IN NO EVENT SHALL WE BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, OR PUNITIVE DAMAGES, INCLUDING LOSS OF DATA, OR OTHER INTANGIBLE LOSSES, RESULTING FROM YOUR USE OF THE APP.'),
            _buildSection(context, '7. Termination', 'We may terminate or suspend your account and access to the App immediately, without prior notice, for any reason whatsoever, including a breach of these Terms. You may terminate your account at any time through the "Delete Account" feature in the App’s settings.'),
            _buildSection(context, '8. Governing Law', 'These Terms shall be governed by and construed in accordance with the laws of the Federal Republic of Nigeria, without regard to its conflict of law provisions.'),
            _buildSection(context, '9. Changes to Terms', 'We reserve the right to modify these Terms at any time. We will notify you of any material changes by posting the new Terms within the App and updating the "Last Updated" date. Your continued use of the App after such changes constitutes your acceptance of the new Terms.'),
            _buildSection(context, '10. Contact Us', 'If you have any questions about these Terms, please contact us at: nisanapptechdev@gmail.com.'),
          ],
        ),
      ),
    );
  }
  Widget _buildSection(BuildContext context, String title, String content) {
    return Padding(padding: const EdgeInsets.only(bottom: 20.0), child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
      Text(title, style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold)),
      const SizedBox(height: 8), Text(content, style: Theme.of(context).textTheme.bodyMedium?.copyWith(height: 1.5)),
    ]));
  }
}

class PrivacyPolicyScreen extends StatelessWidget {
  const PrivacyPolicyScreen({super.key});
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Privacy Policy')),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Last Updated: July 15, 2025', style: Theme.of(context).textTheme.bodySmall?.copyWith(fontStyle: FontStyle.italic)),
            const SizedBox(height: 16),
            _buildSection(context, '1. Our Commitment to Your Privacy', 'NisanApp is committed to protecting your privacy. This Privacy Policy explains how we collect, use, disclose, and safeguard your information when you use our mobile application (the "App"). We do not sell or rent your personal information to third parties.'),
            _buildSection(context, '2. Information We Collect', 'To provide our services, we collect the following types of information:\n\n'
                'A. Information You Provide Directly:\n'
                '• Account Information: When you register, we collect your username, email address, and a securely hashed password.\n'
                '• User Content: We collect the tasks, notes, subtasks, categories, and other data you create and input into the App.\n'
                '• Attachments: The App stores any files you attach (images, PDFs, etc.) in a private directory on your local device. We only store metadata (like file names) in our database to help you manage them; the file contents are not uploaded to our servers.\n\n'
                'B. Information Collected Automatically:\n'
                '• Usage Data: To enhance your experience, we collect anonymous, aggregated data on how you interact with App features (e.g., feature usage frequency, session duration). This data is not personally identifiable.\n'
                '• Device Storage Data (Local): The App uses your device\'s local storage to save your theme preference, unsaved drafts, recent search history, and task priority usage to provide smart defaults. This data remains on your device.'),
            _buildSection(context, '3. How We Use Your Information', 'We use your information for the following purposes:\n\n'
                '• To Provide and Sync the Service: To operate the App, store your data securely, and sync it across your devices in real-time.\n'
                '• To Personalize Your Experience: To offer smart defaults and remember your preferences.\n'
                '• To Improve the App: To analyze usage trends and guide future development.\n'
                '• For Security: To protect your account and the integrity of our services.\n'
                '• To Communicate with You: To send important service-related notifications, if necessary.'),
            _buildSection(context, '4. Data Sharing and Third-Party Services', 'We do not share your personal information except in the limited circumstances described below:\n\n'
                '• Service Providers: We use Google Firebase for our backend infrastructure. This includes Firebase Authentication for secure sign-in and Cloud Firestore for database storage. Your data is stored securely on Google\'s servers, and their use of it is governed by their own privacy policies.\n'
                '• Legal Requirements: We may disclose your information if required by law or in response to valid legal requests from public authorities.'),
            _buildSection(context, '5. Data Security', 'We prioritize the security of your data. We leverage the robust security measures of Google Firebase to protect your information from unauthorized access, alteration, or disclosure. Since attachments are stored locally, their security is also dependent on the security of your device.'),
            _buildSection(context, '6. Your Rights and Data Control', 'You have full control over your data:\n\n'
                '• Access and Edit: You can review and edit your User Content at any time within the App.\n'
                '• Data Portability: You can copy or share your task information at any time.\n'
                '• Deletion: You can permanently delete your account and all associated data through the "Delete Account" feature. This action is irreversible and will also remove your data from our servers.'),
            _buildSection(context, '7. Children’s Privacy', 'NisanApp is not intended for or directed at children under the age of 13. We do not knowingly collect personal information from children under 13.'),
            _buildSection(context, '8. Changes to This Privacy Policy', 'We may update this Privacy Policy from time to time. We will notify you of any changes by posting the new policy within the App and updating the "Last Updated" date.'),
            _buildSection(context, '9. Contact Us', 'For any questions or concerns about this Privacy Policy, please contact our support team at: nisanapptechdev@gmail.com.'),
          ],
        ),
      ),
    );
  }

  Widget _buildSection(BuildContext context, String title, String content) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 20.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(title, style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold)),
          const SizedBox(height: 8),
          Text(content, style: Theme.of(context).textTheme.bodyMedium?.copyWith(height: 1.5)),
        ],
      ),
    );
  }
}

// --- NEW: DEDICATED PDF VIEWER SCREEN ---
class PdfViewerScreen extends StatelessWidget {
  final String filePath;
  const PdfViewerScreen({super.key, required this.filePath});

  @override
  Widget build(BuildContext context) {
    final String fileName = p_path.basename(filePath);

    return Scaffold(
      appBar: AppBar(
        title: Text(fileName),
      ),
      body: PDF(
        onError: (error) {
          AppLogger().log("Error loading PDF: $error");
        },
      ).fromPath(filePath),
    );
  }
}

// --- NEW: DEDICATED IMAGE VIEWER SCREEN ---
// --- NEW: DEDICATED IMAGE VIEWER SCREEN (CORRECTED FOR WEB) ---
class ImageViewerScreen extends StatelessWidget {
  final String imagePath;
  const ImageViewerScreen({super.key, required this.imagePath});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black.withOpacity(0.9),
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        iconTheme: const IconThemeData(color: Colors.white),
      ),
      body: Center(
        // Use a conditional check for the web platform
        child: kIsWeb
        // **WEB:** Display a message. A local mobile file path is not accessible on the web.
            ? const Center(
          child: Text(
            "Local file preview is not supported on web.",
            style: TextStyle(color: Colors.white),
          ),
        )
        // **MOBILE:** Use the original code that works on mobile devices.
            : ExtendedImage.file(
          File(imagePath),
          fit: BoxFit.contain,
          mode: ExtendedImageMode.gesture,
          initGestureConfigHandler: (state) {
            return GestureConfig(
              minScale: 0.9,
              animationMinScale: 0.7,
              maxScale: 4.0,
              animationMaxScale: 4.5,
              speed: 1.0,
              inertialSpeed: 100.0,
              initialScale: 1.0,
              inPageView: false,
              initialAlignment: InitialAlignment.center,
            );
          },
        ),
      ),
    );
  }
}

// --- NEW: DEDICATED ADD SUBTASK SCREEN ---
class AddSubtaskScreen extends StatefulWidget {
  const AddSubtaskScreen({super.key});

  @override
  State<AddSubtaskScreen> createState() => _AddSubtaskScreenState();
}

class _AddSubtaskScreenState extends State<AddSubtaskScreen> {
  final _formKey = GlobalKey<FormState>();
  final _titleController = TextEditingController();
  bool _isSaving = false;

  @override
  void dispose() {
    _titleController.dispose();
    super.dispose();
  }

  void _saveSubtask() {
    if (_formKey.currentState!.validate()) {
      setState(() {
        _isSaving = true;
      });

      final newSubtask = Subtask(
        id: const Uuid().v4(),
        title: _titleController.text.trim(),
        isCompleted: false,
      );

      Navigator.of(context).pop(newSubtask);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Add New Subtask'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              TaskFormField(
                controller: _titleController,
                labelText: 'Subtask Title',
                hintText: 'e.g., Research competitors',
                autofocus: true,
                textCapitalization: TextCapitalization.sentences,
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Please enter a title for the subtask.';
                  }
                  return null;
                },
                onFieldSubmitted: (_) => _saveSubtask(),
              ),
              const Spacer(),
              ElevatedButton.icon(
                onPressed: _isSaving ? null : _saveSubtask,
                icon: _isSaving
                    ? const SizedBox.shrink()
                    : const Icon(Icons.check_circle_outline),
                label: _isSaving
                    ? const CircularProgressIndicator()
                    : const Text('Save Subtask'),
              ),
              const SizedBox(height: 20),
            ],
          ),
        ),
      ),
    );
  }
}

// --- NEW: SCREEN FOR VIEWING ARCHIVED TASKS ---
class ArchivedTasksScreen extends StatelessWidget {
  const ArchivedTasksScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final firestoreService = context.read<FirestoreService>();
    final authService = context.read<AuthService>();
    final taskManager = context.read<TaskManager>();
    final user = authService.currentUser;

    return Scaffold(
      appBar: AppBar(
        title: const Text("Archived Tasks"),
      ),
      body: user == null
          ? const Center(child: Text("Not signed in."))
          : StreamBuilder<List<Task>>(
        stream: firestoreService.getArchivedTasksStream(user.uid),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }
          if (snapshot.hasError) {
            return Center(child: Text("Error: ${snapshot.error}"));
          }
          if (!snapshot.hasData || snapshot.data!.isEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.inventory_2_outlined, size: 70, color: Colors.grey[400]),
                  const SizedBox(height: 20),
                  Text('No Archived Tasks', style: Theme.of(context).textTheme.headlineSmall?.copyWith(color: Colors.grey.shade600)),
                  const SizedBox(height: 8),
                  const Text('Tasks you archive will appear here.', style: TextStyle(color: Colors.grey), textAlign: TextAlign.center),
                ],
              ),
            );
          }

          final archivedTasks = snapshot.data!;
          archivedTasks.sort((a, b) => b.completionTimestamp?.compareTo(a.completionTimestamp ?? DateTime(0)) ?? -1);

          return ListView.builder(
            itemCount: archivedTasks.length,
            itemBuilder: (context, index) {
              final task = archivedTasks[index];
              return Slidable(
                key: ValueKey(task.id),
                startActionPane: ActionPane(
                  motion: const StretchMotion(),
                  children: [
                    SlidableAction(
                      onPressed: (ctx) {
                        taskManager.unarchiveTask(task.id);
                        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("'${task.title}' restored.")));
                      },
                      backgroundColor: Theme.of(context).colorScheme.primary,
                      foregroundColor: Colors.white,
                      icon: Icons.unarchive_outlined,
                      label: 'Restore',
                    ),
                  ],
                ),
                endActionPane: ActionPane(
                  motion: const StretchMotion(),
                  children: [
                    SlidableAction(
                      onPressed: (ctx) => _confirmPermanentDelete(context, task, taskManager),
                      backgroundColor: Theme.of(context).colorScheme.error,
                      foregroundColor: Colors.white,
                      icon: Icons.delete_forever_outlined,
                      label: 'Delete',
                    ),
                  ],
                ),
                child: TaskListItem(
                  task: task,
                  isArchivedView: true,
                  onTap: () {},
                  onLongPress: () {},
                ),
              );
            },
          );
        },
      ),
    );
  }

  Future<void> _confirmPermanentDelete(BuildContext context, Task task, TaskManager taskManager) async {
    final bool? confirmed = await showDialog<bool>(
        context: context,
        builder: (ctx) => AlertDialog(
          title: const Text('Confirm Permanent Deletion'),
          content: Text('Are you sure you want to permanently delete "${task.title}"? This action cannot be undone.'),
          actions: [
            TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('Cancel')),
            TextButton(onPressed: () => Navigator.of(ctx).pop(true), style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.error), child: const Text('Delete Permanently')),
          ],
        ));
    if (confirmed == true && context.mounted) {
      await taskManager.permanentlyDeleteTask(task.id);
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("'${task.title}' has been deleted forever.")));
      }
    }
  }
}
// --- NEW: /lib/src/features/tools/presentation/tools_screen.dart ---
// This screen acts as a hub for utilities.
// --- NEW: /lib/src/features/tools/presentation/tools_screen.dart ---
// This screen acts as a hub for utilities.
// --- NEW: /lib/src/features/tools/presentation/tools_screen.dart ---
// This screen acts as a hub for utilities.
class ToolsScreen extends StatelessWidget {
  const ToolsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("Quick Tools"),
      ),
      body: ListView(
        children: [
          ListTile(
            leading: const Icon(Icons.calculate_outlined),
            title: const Text("Scientific Calculator"),
            subtitle: const Text("For expenses, academic and quick math"),
            onTap: () {
              Navigator.push(
                context,
                MaterialPageRoute(builder: (context) => const CalculatorScreen()),
              );
            },
          ),
          const Divider(),
          ListTile(
            leading: const Icon(Icons.av_timer_rounded),
            title: const Text("Focus Hub"),
            subtitle: const Text("Access the Stopwatch and Timer"),
            onTap: () => Navigator.pushNamed(context, Constants.focusRoute),
          ),
        ],
      ),
    );
  }
}

// --- NEW: /lib/src/features/tools/presentation/calculator_screen.dart ---
// The actual calculator implementation.
class CalculatorScreen extends StatefulWidget {
  const CalculatorScreen({super.key});

  @override
  _CalculatorScreenState createState() => _CalculatorScreenState();
}

class _CalculatorScreenState extends State<CalculatorScreen> {
  String _expression = '';
  String _result = '0';
  String _livePreview = ''; // For instant calculation previews
  bool _isDeg = true; // True for degrees, false for radians

  @override
  void initState() {
    super.initState();
    // Lock screen to portrait mode when entering
    SystemChrome.setPreferredOrientations([
      DeviceOrientation.portraitUp,
      DeviceOrientation.portraitDown,
    ]);
  }

  @override
  void dispose() {
    // Re-enable all orientations when leaving
    SystemChrome.setPreferredOrientations([
      DeviceOrientation.portraitUp,
      DeviceOrientation.portraitDown,
      DeviceOrientation.landscapeLeft,
      DeviceOrientation.landscapeRight,
    ]);
    super.dispose();
  }


  void _onButtonPressed(String buttonText) {
    setState(() {
      if (buttonText == 'C') {
        _expression = '';
        _result = '0';
      } else if (buttonText == '⌫') {
        if (_expression.isNotEmpty) {
          _expression = _expression.substring(0, _expression.length - 1);
        }
      } else if (buttonText == '=') {
        _calculateResult();
      } else if (buttonText == 'DEG' || buttonText == 'RAD') {
        _isDeg = !_isDeg;
      }
      else {
        if (_result == 'Error' || (_expression.isEmpty && _result == '0')) {
          _expression = '';
        }
        // If the last action was '=', start a new expression
        if (_expression == _result && !['+', '-', 'x', '÷', '^'].contains(buttonText)) {
          _expression = '';
        }

        // Handle special function syntax
        if (['sin', 'cos', 'tan', 'log', 'ln', '√'].contains(buttonText)) {
          final func = (buttonText == '√') ? 'sqrt' : buttonText;
          _expression += '$func(';
        } else if (buttonText == 'π') {
          _expression += 'pi';
        }
        else {
          _expression += buttonText;
        }
      }
      _updateLiveResult(); // Update preview on every button press
    });
  }

  void _updateLiveResult() {
    // This regex checks for simple 'number operator number' patterns.
    final simpleExpressionRegex = RegExp(r'^\d+(\.\d+)?\s*([+\-x÷])\s*\d+(\.\d+)?$');
    if (simpleExpressionRegex.hasMatch(_expression.replaceAll(' ', ''))) {
      _calculateResult(isPreview: true);
    } else {
      setState(() {
        _livePreview = '';
      });
    }
  }


  void _calculateResult({bool isPreview = false}) {
    try {
      String finalExpression = _expression.replaceAll('x', '*').replaceAll('÷', '/');
      finalExpression = finalExpression.replaceAllMapped(RegExp(r'(sin|cos|tan)\(([^)]+)\)'), (match) {
        String func = match.group(1)!;
        double value = double.parse(match.group(2)!);
        if (_isDeg) {
          value = value * (pi / 180.0);
        }
        return '$func($value)';
      });

      Parser p = Parser();
      Expression exp = p.parse(finalExpression);
      ContextModel cm = ContextModel();
      double eval = exp.evaluate(EvaluationType.REAL, cm);
      String formattedResult = eval.toStringAsFixed(6).replaceAll(RegExp(r'([.]*0{1,6})(?!.*\d)'), '');

      if (isPreview) {
        _livePreview = '= $formattedResult';
      } else {
        _result = formattedResult;
        _expression = _result;
        _livePreview = '';
      }
    } catch (e) {
      if (!isPreview) {
        _result = 'Error';
      }
      _livePreview = '';
    }
  }


  Widget _buildButton(String buttonText, {Color? color, Color? textColor, int flex = 1}) {
    final theme = Theme.of(context);
    textColor ??= theme.colorScheme.onSurface;
    return Expanded(
      flex: flex,
      child: Padding(
        padding: const EdgeInsets.all(4.0),
        child: ElevatedButton(
          style: ElevatedButton.styleFrom(
            padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 8),
            backgroundColor: color ?? theme.colorScheme.surfaceVariant.withOpacity(0.5),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          ),
          child: FittedBox(
            child: Text(
              buttonText,
              style: TextStyle(
                fontSize: 20.0,
                fontWeight: FontWeight.bold,
                color: textColor,
              ),
            ),
          ),
          onPressed: () => _onButtonPressed(buttonText),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(
        title: const Text('Scientific Calculator'),
        actions: [
          IconButton(
            icon: const Icon(Icons.copy),
            tooltip: "Copy Result",
            onPressed: () {
              Clipboard.setData(ClipboardData(text: _result));
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('Result "$_result" copied to clipboard!')),
              );
            },
          )
        ],
      ),
      body: SafeArea(
        child: Column(
          children: <Widget>[
            Expanded(
              flex: 3, // Reduced flex to give more space to buttons
              child: Container(
                alignment: Alignment.bottomRight,
                padding: const EdgeInsets.symmetric(vertical: 16.0, horizontal: 12.0),
                child: SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  reverse: true,
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.end,
                    crossAxisAlignment: CrossAxisAlignment.end,
                    children: [
                      Text(_livePreview, style: theme.textTheme.headlineSmall?.copyWith(color: theme.colorScheme.primary)),
                      const SizedBox(height: 8),
                      Text(_expression, style: theme.textTheme.headlineMedium?.copyWith(color: Colors.grey)),
                      Text(_result, style: theme.textTheme.displaySmall),
                    ],
                  ),
                ),
              ),
            ),
            const Divider(height: 1),
            Expanded(
              flex: 5, // Increased flex for buttons
              child: Padding(
                padding: const EdgeInsets.all(8.0),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    Expanded(child: Row(children: [
                      _buildButton(_isDeg ? 'DEG' : 'RAD', color: theme.colorScheme.secondaryContainer, textColor: theme.colorScheme.onSecondaryContainer),
                      _buildButton('sin', color: theme.colorScheme.tertiaryContainer, textColor: theme.colorScheme.onTertiaryContainer),
                      _buildButton('cos', color: theme.colorScheme.tertiaryContainer, textColor: theme.colorScheme.onTertiaryContainer),
                      _buildButton('tan', color: theme.colorScheme.tertiaryContainer, textColor: theme.colorScheme.onTertiaryContainer),
                    ])),
                    Expanded(child: Row(children: [
                      _buildButton('^', color: theme.colorScheme.tertiaryContainer, textColor: theme.colorScheme.onTertiaryContainer),
                      _buildButton('ln', color: theme.colorScheme.tertiaryContainer, textColor: theme.colorScheme.onTertiaryContainer),
                      _buildButton('log', color: theme.colorScheme.tertiaryContainer, textColor: theme.colorScheme.onTertiaryContainer),
                      _buildButton('√', color: theme.colorScheme.tertiaryContainer, textColor: theme.colorScheme.onTertiaryContainer),
                    ])),
                    Expanded(child: Row(children: [
                      _buildButton('('), _buildButton(')'),
                      _buildButton('π'), _buildButton('e'),
                    ])),
                    Expanded(child: Row(children: [
                      _buildButton("7"), _buildButton("8"), _buildButton("9"),
                      _buildButton("÷", color: theme.colorScheme.primary, textColor: theme.colorScheme.onPrimary),
                    ])),
                    Expanded(child: Row(children: [
                      _buildButton("4"), _buildButton("5"), _buildButton("6"),
                      _buildButton("x", color: theme.colorScheme.primary, textColor: theme.colorScheme.onPrimary),
                    ])),
                    Expanded(child: Row(children: [
                      _buildButton("1"), _buildButton("2"), _buildButton("3"),
                      _buildButton("-", color: theme.colorScheme.primary, textColor: theme.colorScheme.onPrimary),
                    ])),
                    Expanded(child: Row(children: [
                      _buildButton("."), _buildButton("0"), _buildButton("⌫"),
                      _buildButton("+", color: theme.colorScheme.primary, textColor: theme.colorScheme.onPrimary),
                    ])),
                    Expanded(child: Row(children: [
                      _buildButton("C", color: theme.colorScheme.errorContainer, textColor: theme.colorScheme.onErrorContainer),
                      _buildButton("=", flex: 3, color: theme.colorScheme.primary, textColor: theme.colorScheme.onPrimary),
                    ])),
                  ],
                ),
              ),
            )
          ],
        ),
      ),
    );
  }
}


// --- NEW: /lib/src/features/categories/presentation/manage_categories_screen.dart ---
class ManageCategoriesScreen extends StatelessWidget {
  const ManageCategoriesScreen({super.key});

  // Dialog to add or edit a category
  void _showAddOrEditCategoryDialog(BuildContext context, {Category? category}) {
    showDialog(
      context: context,
      builder: (ctx) => AddEditCategoryDialog(category: category),
    );
  }

  // **NEW**: A sleek bottom sheet for category options
  void _showCategoryOptions(BuildContext context, Category category) {
    final categoryManager = context.read<CategoryManager>();
    showModalBottomSheet(
      context: context,
      builder: (ctx) {
        return Wrap(
          children: <Widget>[
            ListTile(
              leading: Icon(Icons.edit_outlined, color: Theme.of(context).colorScheme.primary),
              title: const Text('Edit Category'),
              onTap: () {
                Navigator.of(ctx).pop(); // Close the bottom sheet
                _showAddOrEditCategoryDialog(context, category: category);
              },
            ),
            ListTile(
              leading: Icon(Icons.delete_outline, color: Theme.of(context).colorScheme.error),
              title: Text('Delete Category', style: TextStyle(color: Theme.of(context).colorScheme.error)),
              onTap: () {
                Navigator.of(ctx).pop(); // Close the bottom sheet
                _confirmDelete(context, category, categoryManager);
              },
            ),
          ],
        );
      },
    );
  }

  // Confirmation dialog for deleting
  void _confirmDelete(BuildContext context, Category category, CategoryManager manager) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Confirm Deletion'),
        content: Text('Are you sure you want to delete the "${category.name}" category? This cannot be undone.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              manager.deleteCategory(category.id);
              Navigator.of(ctx).pop();
            },
            style: ElevatedButton.styleFrom(backgroundColor: Theme.of(context).colorScheme.error),
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Manage Categories'),
        actions: [
          // A little hint for the user
          Tooltip(
            message: "Long-press a category for options",
            child: IconButton(
              icon: const Icon(Icons.info_outline),
              onPressed: () {},
            ),
          )
        ],
      ),
      body: Consumer<CategoryManager>(
        builder: (context, categoryManager, child) {
          if (categoryManager.isLoading) {
            return const Center(child: CircularProgressIndicator());
          }
          if (categoryManager.categories.isEmpty) {
            return Center(
              child: Padding(
                padding: const EdgeInsets.all(24.0),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(Icons.label_off_outlined, size: 70, color: Colors.grey[400]),
                    const SizedBox(height: 20),
                    Text('No Categories Yet', style: Theme.of(context).textTheme.headlineSmall?.copyWith(color: Colors.grey.shade600)),
                    const SizedBox(height: 8),
                    const Text(
                      'Tap the + button to create categories like "Work" or "Personal" to organize your items.',
                      style: TextStyle(color: Colors.grey),
                      textAlign: TextAlign.center,
                    ),
                  ],
                ),
              ),
            );
          }
          final categories = categoryManager.categories
            ..sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));

          // **REFINED**: Replaced Slidable with GestureDetector for a better UX
          return ListView.builder(
            itemCount: categories.length,
            itemBuilder: (context, index) {
              final category = categories[index];
              return Card(
                margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                child: ListTile(
                  leading: Icon(category.icon, color: category.color, size: 28),
                  title: Text(category.name, style: const TextStyle(fontWeight: FontWeight.w600)),
                  trailing: const Icon(Icons.chevron_right),
                  onTap: () => Navigator.pushNamed(context, Constants.categoryContentsRoute, arguments: category),
                  onLongPress: () => _showCategoryOptions(context, category),
                ),
              );
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _showAddOrEditCategoryDialog(context),
        tooltip: 'Add Category',
        child: const Icon(Icons.add),
      ),
    );
  }
}

// 4. NEW: Helper Dialog for Adding/Editing Categories with Icons & Colors
// Action: Add this new helper widget to your project.

class AddEditCategoryDialog extends StatefulWidget {
  final Category? category;
  const AddEditCategoryDialog({super.key, this.category});

  @override
  State<AddEditCategoryDialog> createState() => _AddEditCategoryDialogState();
}

class _AddEditCategoryDialogState extends State<AddEditCategoryDialog> {
  late final TextEditingController _controller;
  late Color _selectedColor;
  late IconData _selectedIcon;

  final List<IconData> _icons = [
    Icons.label_outline, Icons.work_outline, Icons.person_outline,
    Icons.shopping_cart_outlined, Icons.lightbulb_outline, Icons.home_outlined,
    Icons.school_outlined, Icons.favorite_border, Icons.book_outlined,
    Icons.movie_outlined, Icons.music_note_outlined, Icons.fitness_center,
    Icons.travel_explore, Icons.health_and_safety_outlined, Icons.code,
    Icons.attach_money_outlined
  ];

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController(text: widget.category?.name ?? '');
    _selectedColor = widget.category?.color ?? Colors.grey.shade600;
    _selectedIcon = widget.category?.icon ?? Icons.label_outline;
  }

  void _submitCategory(BuildContext ctx) {
    final name = _controller.text.trim();
    if (name.isNotEmpty) {
      final categoryManager = context.read<CategoryManager>();
      // **FIXED LOGIC**: Check if we are editing or creating a new one.
      if (widget.category != null) {
        // We are editing: create an updated Category object.
        final updatedCategory = Category(
          id: widget.category!.id,
          name: name,
          colorValue: _selectedColor.value,
          iconCodepoint: _selectedIcon.codePoint,
        );
        categoryManager.updateCategory(updatedCategory);
      } else {
        // We are adding: create a brand new Category object.
        final newCategory = Category(
          id: const Uuid().v4(),
          name: name,
          colorValue: _selectedColor.value,
          iconCodepoint: _selectedIcon.codePoint,
        );
        categoryManager.addCategory(newCategory);
      }
      Navigator.of(ctx).pop();
    }
  }

  void _showIconPicker() {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Select an Icon'),
        content: SizedBox(
          width: double.maxFinite,
          child: GridView.builder(
            shrinkWrap: true,
            gridDelegate:
            const SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 5),
            itemCount: _icons.length,
            itemBuilder: (_, index) {
              final icon = _icons[index];
              return IconButton(
                icon: Icon(icon),
                color: _selectedIcon.codePoint == icon.codePoint
                    ? Theme.of(context).colorScheme.primary
                    : null,
                onPressed: () {
                  setState(() => _selectedIcon = icon);
                  Navigator.of(ctx).pop();
                },
              );
            },
          ),
        ),
      ),
    );
  }

  // A simple color picker. In a real app, you might use a package like flutter_colorpicker.
  void _showColorPicker() {
    final List<Color> colors = [
      Colors.grey.shade600, Colors.redAccent, Colors.blueAccent, Colors.green,
      Colors.orange, Colors.purple, Colors.teal, Colors.pink,
    ];
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Select a Color'),
        content: SizedBox(
          width: double.maxFinite,
          child: GridView.builder(
              shrinkWrap: true,
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 4),
              itemCount: colors.length,
              itemBuilder: (_, index) {
                final color = colors[index];
                return InkWell(
                  onTap: () {
                    setState(() => _selectedColor = color);
                    Navigator.of(ctx).pop();
                  },
                  child: Container(
                    margin: const EdgeInsets.all(6),
                    decoration: BoxDecoration(
                      color: color,
                      shape: BoxShape.circle,
                      border: _selectedColor.value == color.value ? Border.all(
                          color: Theme.of(context).colorScheme.onSurface,
                          width: 2.5
                      ) : null,
                    ),
                  ),
                );
              }
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(widget.category != null ? 'Edit Category' : 'New Category'),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            TextField(
              controller: _controller,
              autofocus: true,
              decoration: const InputDecoration(labelText: 'Category Name'),
              textCapitalization: TextCapitalization.words,
              onSubmitted: (_) => _submitCategory(context),
            ),
            const SizedBox(height: 24),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                Column(
                  children: [
                    const Text("Icon"),
                    const SizedBox(height: 8),
                    InkWell(
                      onTap: _showIconPicker,
                      borderRadius: BorderRadius.circular(50),
                      child: Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                            shape: BoxShape.circle,
                            border: Border.all(color: Theme.of(context).colorScheme.outline.withOpacity(0.5))
                        ),
                        child: Icon(_selectedIcon, color: _selectedColor, size: 32),
                      ),
                    ),
                  ],
                ),
                Column(
                  children: [
                    const Text("Color"),
                    const SizedBox(height: 8),
                    InkWell(
                      onTap: _showColorPicker,
                      borderRadius: BorderRadius.circular(50),
                      child: Container(
                        height: 56,
                        width: 56,
                        decoration: BoxDecoration(
                            color: _selectedColor,
                            shape: BoxShape.circle,
                            border: Border.all(color: Theme.of(context).colorScheme.outline.withOpacity(0.5))
                        ),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        ElevatedButton(
          onPressed: () => _submitCategory(context),
          child: const Text('Save'),
        ),
      ],
    );
  }
}

// --- NEW WIDGET: /lib/src/features/categories/presentation/category_input.dart ---
// A reusable widget for selecting and creating categories.

class CategoryInput extends StatefulWidget {
  final List<String> selectedCategories;
  final ValueChanged<List<String>> onChanged;

  const CategoryInput({
    super.key,
    required this.selectedCategories,
    required this.onChanged,
  });

  @override
  State<CategoryInput> createState() => _CategoryInputState();
}

class _CategoryInputState extends State<CategoryInput> {
  final _textController = TextEditingController();
  final _focusNode = FocusNode();
  OverlayEntry? _overlayEntry;
  final LayerLink _layerLink = LayerLink();

  @override
  void initState() {
    super.initState();
    _focusNode.addListener(() {
      if (_focusNode.hasFocus) {
        _showOverlay();
      } else {
        _removeOverlay();
      }
    });
  }

  @override
  void dispose() {
    _textController.dispose();
    _focusNode.dispose();
    _removeOverlay();
    super.dispose();
  }

  void _showOverlay() {
    _overlayEntry = _createOverlayEntry();
    Overlay.of(context).insert(_overlayEntry!);
  }

  void _removeOverlay() {
    _overlayEntry?.remove();
    _overlayEntry = null;
  }

  void _addCategory(String categoryName) {
    final trimmed = categoryName.trim();
    if (trimmed.isNotEmpty && !widget.selectedCategories.contains(trimmed)) {
      final newCategories = [...widget.selectedCategories, trimmed];
      widget.onChanged(newCategories);
    }
    _textController.clear();
    _removeOverlay();
    _showOverlay(); // Rebuild overlay to update suggestions
  }

  void _removeCategory(String categoryName) {
    final newCategories = widget.selectedCategories.where((c) => c != categoryName).toList();
    widget.onChanged(newCategories);
  }

  OverlayEntry _createOverlayEntry() {
    final renderBox = context.findRenderObject() as RenderBox;
    final size = renderBox.size;

    return OverlayEntry(
      builder: (context) {
        // Use a ValueListenableBuilder to react to text changes for filtering
        return ValueListenableBuilder<TextEditingValue>(
          valueListenable: _textController,
          builder: (context, value, child) {
            final categoryManager = context.watch<CategoryManager>();
            final allCustomCategories = categoryManager.categories.map((c) => c.name).toList();

            final suggestions = allCustomCategories.where((category) =>
            category.toLowerCase().contains(value.text.toLowerCase()) &&
                !widget.selectedCategories.contains(category)).toList();

            if (value.text.isEmpty || suggestions.isEmpty) {
              return const SizedBox.shrink();
            }

            return Positioned(
              width: size.width,
              child: CompositedTransformFollower(
                link: _layerLink,
                showWhenUnlinked: false,
                offset: Offset(0.0, size.height + 5.0),
                child: Material(
                  elevation: 4.0,
                  borderRadius: BorderRadius.circular(8),
                  child: ConstrainedBox(
                    constraints: const BoxConstraints(maxHeight: 200),
                    child: ListView.builder(
                      padding: EdgeInsets.zero,
                      shrinkWrap: true,
                      itemCount: suggestions.length,
                      itemBuilder: (context, index) {
                        return ListTile(
                          dense: true,
                          title: Text(suggestions[index]),
                          onTap: () {
                            _addCategory(suggestions[index]);
                            _focusNode.unfocus();
                          },
                        );
                      },
                    ),
                  ),
                ),
              ),
            );
          },
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    return CompositedTransformTarget(
      link: _layerLink,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (widget.selectedCategories.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(bottom: 8.0),
              child: Wrap(
                spacing: 8.0,
                runSpacing: 4.0,
                children: widget.selectedCategories
                    .map((category) => Chip(
                  label: Text(category),
                  onDeleted: () => _removeCategory(category),
                  materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                )).toList(),
              ),
            ),
          TextFormField(
            controller: _textController,
            focusNode: _focusNode,
            decoration: const InputDecoration(
              labelText: 'Categories / Tags',
              hintText: 'Type to add or select a category',
              prefixIcon: Icon(Icons.label_outline),
            ),
            onChanged: (value) {
              _removeOverlay();
              if(value.isNotEmpty) _showOverlay();
            },
            onFieldSubmitted: _addCategory,
          ),
        ],
      ),
    );
  }
}